Section 1: Introduction:
-----------------------

Data-plane algorithms today are hand picked carefully by switch designers for
inclusion into a new hardware-based merchant-silicon switch.

Programmable switch architectures could probably change that.
(Programmability is driven by the realization that it doesn't cost
too much. The area is already dominated by memories and Serial Link IO., so
programmability adds only about 15% net-net)

Now, looking at data-plane algorithms. We observe that these are best expressed as transactions
--> Which looks very different from the architecture of these programmable switches (a pipeline)
--> The ideal place to bridge this gap is a compiler.

Contributions:
--> The observation that data-plane algorithms be structured as transactions.
--> Compiler to translate it into programmable hardware.
--> How this compiler world-view help us longer-term against a landscape of
    evolving switch architectures.

Section 2: Data-plane algorithms:
--------------------------
Describe a few examples (CONGA, CoDel, RED, XCP, min. sketch, Bloom Filters)
--> Distinguishing characteristics:
   --> too expressive for P4.
   --> Intricate control flow.
   --> best structured as transactions.
--> Approximate nature of some algorithm
   --> Some can also be approximated (RED, PIE, sketches, no spec).
   --> Talk about how this is useful to leverage.

Section 3: Data-plane algorithms as transactions
--------------------------
Language: No loops, no break, no continue, no switch, goto
Chang's description: O(1) code.
What we can't do: scans, loops, etc.

Show how some examples from the preceding section can be expressed in our
language.

Section 4: The hardware
-----------------------------
The RMT model: Provisioned for worst-case performance.
--> VLIW packet primitives
--> Almost one-to-one mapping from the P4 action primitives to hardware operations.

Stateful operations:
--> Read-Modify-Write,
--> Atomic Increment,
--> Multiply Accumulate or Conditional Execution
--> Tupled instructions

To justify and show that this isn't a fantasy model of a switch:
--> Talk about how DSPs support some of these ops. MAC on TI's DSP, Packed Instructions on Intel's SSE.
--> How we have talked to industry folks about it and so on.
--> Many of these are already done in fixed form today: counters, EWMA
--> Talk about how P4 already has primitives for some of these: register references: rref.

Section 5: The compiler, with running example of CRC16 + control flow + state
that maps correctly
----------------------------------------------------------------------
Talk about why source-to-source is the right level:
1. Same levels of abstraction for source and target.
2. Easier to interpret output (lexically and control flow)
3. Industry is already investing considerable effort in taking a source language (P4) down to the switch backend.
Focus on problems that industry doesn't have the time to solve.

Describe compiler in passes:
--> scalar replacement (from member expressions to local variables),
--> if conversion (from branches to ternary operators)
--> boolean minimization, removing ternary ops if possible
--> canonicalization to conform to the target architecture:
      --> Expression flattening for stateful and stateless ops
      --> rewriting stateful transformations into a form that the hardware can support.
      --> for instance, x = x + 1 might stay as such or might have to be rewritten into tmp = x; tmp2 = x + 1; x = tmp2
          depending on what is supported
      --> I think the invariant at this stage is that:
          a single packet program runs correctly on the target architecture.
--> generate dag using dependency analysis (RAW, WAR, WAW)
--> Recirculate if required. (This is the best we can do for a stream of packets.)
--> partitioning
--> Convert back into packet primitives

Advanced idioms:
--> Pipeline wide memory using recirculation primitive.
--> Tupled Stateful operations: <x, y> <--- f(x, y).
--> Multiply accumulate (MAC).

Show the actual generated code.

Section 6: Evaluation:
---------------------
Tick-based ppeline simulator, open-loop Poisson traffic

--> Show one correct mapping, just demonstrates correctness.
--> Present EWMA example. Show how
    --> Without MAC or tupled instructions, you need to use recirculation,
        which leverages the approximate nature of some of these instructions.
    --> With MAC instructions, you can do it exactly.

Section 7: Related Work:
---------------------------
NPUs: Tradeoffs are different here. Each stage can do very very little.
P4 compiler: Complementary backend.
CMU work on pipelining datapaths: Verilog and circuits.
P4: Too low level.
NetASM: Once P4 needs an IR, NetASM might be a good choice.
Click: P4 paper wrote it off. We think its worth revisiting here.
Fastpass or Flexplane: Say that you love the abstraction they propose,
but would love to do it at higher line rates.
Maple

Section 8: Future Work and Outlook:
----------------------------
Arrays and other aggregates.
Table layout: compiling to P4 and then go down.
TCP traffic and end-to-end evaluation of approximation quality like video quality in approximate computing.
So far our approach to evaluating approximations is empirical, not analytical. Analysis would be awesome.
