\section{Related work}
\label{s:related}
%TODO: opendataplane.org
%%\textbf{Data-Plane Algorithms}
%%Several data-plane algorithms are now commonplace, e.g., lookup algorithms based
%%on longest-prefix, exact, or ternary matches.  \pktlanguage focuses on
%%data-plane algorithms that aren't widely available because of the engineering
%%effort required for hardware implementations.  Further, the growing list of new
%%algorithms~\cite{pdq, d3, detail, codel, conga} makes it hard to commit to a
%%hardware implementation. \pktlanguage allows network programmers to modify
%%these algorithms more rapidly.

\textbf{Abstract machines for line-rate switches}
%%Relative to P4's abstract switch model~\cite{p4}, \absmachine contributes the
%%notion of atoms.
%%
NetASM~\cite{netasm} is an abstract machine and intermediate representation
(IR) for programmable data planes that is portable across network
devices---FPGAs, virtual switches, and line-rate switches.  \absmachine is a
machine model for line-rate switches alone, and hence models practical
constraints required for line-rate packet processing that NetASM doesn't. For
instance, \absmachine machines don't permit sharing state between atoms and use
atom templates to limit the amount of packet processing that can happen at line
rate. Further, while NetASM's dataflow framework focuses only on
target-independent middle-end optimizations such as dead-code elimination, the
\pktlanguage compiler shows how to implement a compiler back-end for line-rate
switches (\S\ref{ss:code_gen}).

\textbf{Programmable Data Planes}
Software data planes such as Click~\cite{click},
RouteBricks~\cite{routebricks}, and Fastpass~\cite{fastpass} are flexible but
lack the performance required for large-scale deployments. Network
Processors~\cite{ixp2800, ixp4xx} (NPUs) were an attempt to bridge the gap.
While NPUs are faster than software routers, they remain an order of magnitude
slower than merchant silicon chips~\cite{rmt}. Eden~\cite{eden} provides a
programmable data plane using commodity switches by programming end hosts
alone. \pktlanguage targets programmable switches that increase the scope of
programmable data planes relative to an end-host-only solution. For instance,
they permit us to express in-network congestion control, AQM, and
congestion-aware load balancing (CONGA), which are beyond Eden's capabilities.

%TODO: TPP?
%TODO: Consider removing the stuff below.
An alternative is to use FPGAs; examples include NetFPGA~\cite{netfpga},
Switchblade~\cite{switchblade}, and Chimpp~\cite{chimpp}.  These designs are
slower than switching ASICs, and are rarely used in production network
equipment. The Arista 7124 FX~\cite{7124fx} is a commercial switch with an
on-board FPGA, but its capacity is limited to 160 Gbits/sec when using the
on-board FPGA---~10x less than the multi-terabit capacities of programmable
switch chips~\cite{xpliant}.

Recent work~\cite{lavanya_compiler} focuses on compiling P4 programs to
programmable data planes such as the RMT and FlexPipe architectures. However,
their work focuses on compiling stateless data-plane tasks such as forwarding
and routing, while \pktlanguage focuses on stateful data-plane algorithms.

\textbf{Packet-processing languages}
Many programming languages target the network control plane. Examples include
Frenetic~\cite{frenetic}, Pyretic~\cite{pyretic}, and Maple~\cite{maple}.
\pktlanguage focuses on the data plane. Several DSLs target data-plane packet
processing. Click~\cite{click} uses C++ for packet processing on software
routers. Imperative languages such as NOVA~\cite{nova}, packetC~\cite{packetc},
Intel's auto-partitioning C compiler~\cite{intel_uiuc_pldi},
PacLang~\cite{paclang_lang, paclang_partitioner}, and Microengine
C~\cite{microenginec, intel_ixa} target network processors~\cite{ixp2800,
ixp4xx}.

\pktlanguage's C-like syntax and sequential semantics are inspired by these
DSLs. However \pktlanguage is constrained relative to them: for instance, it
forbids loops and includes no synchronization constructs because there is no
shared state in \absmachine machines. These constraints were chosen to target
line-rate switching chips with shared-nothing architectures.  Furthermore,
\pktlanguage's compiler presents a different programming model: all
\pktlanguage programs that compile run at line-rate. Unlike an NPU or software
router, there is no slippery slope of degrading performance with increasing
program complexity.

SNAP~\cite{snap} is a language for programming stateful data-plane algorithms
using a network transaction: an atomic block of code that treats the entire
network as one big switch~\cite{onebigswitch}. The SNAP compiler then
translates these network transactions into rules running on each
switch/middlebox. SNAP doesn't determine if these switch-local rules can be
mapped into the pipeline of a programmable line-rate switch. \pktlanguage can
potentially be used to compile SNAP's switch-local rules to an atom pipeline
and is an enabler for SNAP and other network-wide abstractions.
