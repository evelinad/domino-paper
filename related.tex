\section{Related work}
\label{s:related}
\textbf{Abstract machines for line-rate switches:}
NetASM~\cite{netasm} is an abstract machine and intermediate representation
(IR) for programmable data planes that is portable across network
devices---FPGAs, virtual switches, and line-rate switches.  \absmachine is a
low-level machine model for line-rate switches alone and can be used as a
NetASM target. Because of its role as a low-level machine model, \absmachine
models practical constraints required for line-rate forwarding that an IR like
NetASM doesn't have to. For instance, \absmachine machines don't permit sharing
state between atoms and use atom templates to limit computations that can
happen at line rate.

%Further, while NetASM's dataflow framework
%focuses only on target-independent middle-end optimizations such as dead-code
%elimination, the \pktlanguage compiler implements a compiler back-end for
%line-rate switches (\S\ref{ss:code_gen}).

\textbf{Programmable data planes:}
Software data planes such as Click~\cite{click} and
RouteBricks~\cite{routebricks}, and network processors~\cite{ixp4xx} (NPUs) are
flexible, but at least \textasciitilde10$\times$ slower than switching
chips~\cite{rmt}.

Eden~\cite{eden} provides a programmable data plane using commodity switches by
programming end hosts alone. \pktlanguage targets programmable switches that
increase the scope of programmable data planes relative to an end-host-only
solution. For instance, \pktlanguage permits us to express in-network
congestion control, AQM, and congestion-aware load balancing (CONGA), which are
beyond Eden's capabilities. Tiny Packet Programs (TPP)~\cite{tpp} allow end
hosts to embed small programs in packet headers, which are then executed by the
switch. TPPs are written in a restricted instruction set to facilitate switch
execution; we show that switch instructions must and can be substantially
richer (Table~\ref{tab:templates}) to support stateful data-plane algorithms.

An alternative is to utilize an FPGA-based platform such as the NetFPGA~\cite{netfpga}.
These platforms are
slower than switching ASICs, and are rarely used in production network
equipment. The Arista 7124 FX~\cite{7124fx} is a commercial switch with an
on-board FPGA, but its capacity is limited to 160 Gbits/sec when using the
on-board FPGA---10$\times$ lower than the multi-terabit capacities of programmable
switching chips~\cite{xpliant, tofino}.

Jose et al.~\cite{lavanya_compiler} focus on compiling P4 programs to
programmable data planes such as the RMT and FlexPipe architectures. Their work
focuses only on compiling stateless data-plane tasks such as forwarding and
routing, while \pktlanguage handles stateful data-plane algorithms.

\textbf{Packet-processing languages:}
Many programming languages~\cite{frenetic, maple} target the network control plane.
\pktlanguage focuses on the data plane instead, which requires different
programming constructs and compilation techniques.

Several DSLs target the data-plane. Click~\cite{click} uses C++ for packet
processing on software routers. packetC~\cite{packetc}, Intel's
auto-partitioning C compiler~\cite{intel_uiuc_pldi}, , and Microengine
C~\cite{microenginec} target network processors. \pktlanguage's C-like syntax
and sequential semantics are inspired by these DSLs. However, by targeting
line-rate switches, \pktlanguage is more constrained: e.g., because it ensures
that compiled programs can run at line-rate, the language forbids loops and
includes no synchronization constructs as there is no shared state in
\absmachine machines.

SNAP~\cite{snap} programs stateful data-plane algorithms using a network
transaction: an atomic block of code that treats the entire network as one
switch~\cite{onebigswitch} and uses a compiler to translate network
transactions into rules on each switch. SNAP doesn't compile these switch-local
rules into a switch's pipeline. \pktlanguage can be used to compile SNAP's
switch-local rules to an atom pipeline. FAST~\cite{fast} provides switch
support and software abstractions for state machines. \absmachine's atoms
support more general stateful processing beyond state machines that enable a
much wider class of data-plane algorithms.
