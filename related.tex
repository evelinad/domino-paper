\section{Related work}
\label{s:related}

%TODO: Maybe mention Databases here?
%% Transactions~\cite{db_trans} are the strongest guarantee that a database system
%% can provide in that the effect of a transaction is either entirely visible or
%% not with no intermediate state being visible to the outside world.
%% \ac{I would cut references to DB since we don't provide rollback}              \textbf{Data-Plane Algorithms}
Several data-plane algorithms are now commonplace and available in all
switches. Canonical examples are lookup algorithms based on longest-prefix
match, exact match, ternary match and range-search. \pktlanguage focuses on
data-plane algorithms that aren't widely available because of the considerable
engineering effort required for hardware implementations. Further, the rapidly
growing list of new algorithms~\cite{pdq, d3, detail, codel, conga} makes it
challenging to commit to a hardware implementation for any of them.  Expressing
these in \pktlanguage allows designers to iterate on these algorithms at
software timescales.

%%For instance, load-balancing algorithms such as CONGA~\cite{conga} are
%%available only on a specific line of CISCO switches.  Active queue-management
%%algorithms such as CoDel~\cite{codel} need to be extensively
%%modified~\cite{pie} to suit the architecture of a line-rate switch.  Explicit
%%congestion-control algorithms such as RCP~\cite{rcp} and XCP~\cite{xcp}, and
%%measurement algorithms such as OpenSketch~\cite{opensketch} have been evaluated
%%only on FPGA-based platforms.

\textbf{Abstract machines for line-rate switches}
The protocol-independent switch architecture~\cite{nick_p4} and P4's abstract
switch model~\cite{p4} are two abstract machines for programmable switches.
Relative to P4's abstract switch model, \absmachine contributes the notions of
atoms, sequential execution within atoms, and state encapsulated by atoms.
\absmachine can be seen as an executable instantiation of the
protocol-independent switch architecture.

Closest to \absmachine is NetASM~\cite{netasm}, which introduces an
intermediate representation and abstract machine for programmable data planes.
\absmachine differs from NetASM by explicitly targeting line-rate forwarding in
two ways.  First, all state in \absmachine is internal to an atom (and hence
internal to the atom's stage), while NetASM's ATM construct allows access to
shared state from multiple pipeline stages. Second, \absmachine also explicitly
enforces constraints on the amount of useful work that can be carried out in an
atom.
% --> Their cost models include area and latency. We leave this to P4.

\textbf{Programmable Data Planes}
Several programmable data planes exist today. Software-based solutions such as
Click~\cite{click}, Fastpass~cite{fastpass} and Flexplane~\cite{flexplane} are
flexible but lack the performance required for deployments. Network
Processors~\cite{intel, ixp2800, ixp} (NPUs) were an attempt to bridge the gap.
While NPUs are faster than software routers, they still remain an order of
magnitude slower than merchant silicon chips~\cite{rmt}. \pktlanguage focuses on
programmable switch architectures that run at line rate.

\textbf{Packet-processing languages}
Several DSLs explicitly target packet processing. Click~\cite{click} uses C++
to write packet-processing code for software routers. Imperative languages such
as NOVA~\cite{nova}, packetC~\cite{packetc} Intel's auto-partitioning C
compiler~\cite{intel_uiuc_pldi} and Microengine C~\cite{microenginec,
intel_ixa} target network processors such as the Intel IXP~\cite{ixp2800, ixp}.
PX~\cite{PX} is a language that targets packet processing on FPGA platforms.

\pktlanguage's use of C syntax and the implicit sequential semantics of C are
inspired by these languages. However \pktlanguage is more constrained than its
predecessors: for instance, \pktlanguage forbids loops and includes no
synchronization constructs because all state is internal to an atom. These were
deliberately chosen to target line-rate switching chips with deterministic
performance and shared-nothing memory architectures.

As a result, \pktlanguage's compiler presents a different view to the
programmer relative to these prior systems: all \pktlanguage programs that
compile run at line-rate, while those that can't run at line rate are rejected
outright. There is no slippery slope of degrading performance as the program's
complexity increases.

P4~\cite{p4} is an emerging packet-processing language that explicitly targets
line-rate programmable switching chips. However, P4's language constructs
resemble the underlying hardware---requiring the programmer to reason about
concurrency and pipelining. Further, P4 currently has no constructs for
sequential execution within a pipeline stage.

Sequential execution within a stage is required to execute the atoms produced
by \pktlanguage and guarantee correctness. Based on this work, we have
submitted a proposal for the same~\cite{p4-semantics} to the P4 language
consortium. In the future, if P4 supports such constructs, \pktlanguage could
target P4 as a backend, allowing us to leverage ongoing work ~\cite{netronome,
xilinx,lavanya_compiler} in compiling P4 to hardware targets.

\textbf{Compiler Techniques}
\pktlanguage's compiler uses three-address codes~\cite{tac}, static-single
assignment form~\cite{ssa}, and if conversion~\cite{if_conversion}, all of
which are well-understood in the compiler literature. However, \pktlanguage's
constrained design allows us to considerably simplify these techniques relative
to their current uses in compilers. \tester can be viewed as an informal
counterpart of translation validation~\cite{necula_translation_validation},
which guarantees that a compiler pass preserves program semantics.

\pktlanguage use of strongly connected components to determine atom bodies is
based on similar uses in software pipelining~\cite{software_pipelining} for
VLIW and DSP architectures. However, dependence analysis for loop-carried
dependencies in software pipelining (equivalent to state in \pktlanguage) is
more involved than the simple syntactic analysis of dependencies employed by
\pktlanguage. Lastly, the use of synthesis to fit atom bodies into sketches is
based on Chlorophyll's~\cite{chlorophyll} use of program synthesis for
compilation to unorthodox targets.

\textbf{Hardware compilation}
Prior work ~\cite{nurvadathi, cash, bluespec} has focused on deriving hardware
circuits from high-level imperative descriptions of program behavior for
arbitrary kernels. While these approaches simplify hardware development, the
performance of each kernel depends on its complexity.  \pktlanguage has an
all-or-nothing approach to performance: all code that compiles can run at
line rate or is rejected by the compiler.
