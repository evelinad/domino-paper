\section{Related work}
\label{s:related}
\textbf{Abstract machines for line-rate switches:}
NetASM~\cite{netasm} is an abstract machine and intermediate representation
(IR) for programmable data planes that is portable across network
devices---FPGAs, virtual switches, and line-rate switches.  \absmachine is a
machine model for line-rate switches alone, and hence models practical
constraints required for line-rate forwarding that NetASM doesn't. For
instance, \absmachine machines don't permit sharing state between atoms and use
atom templates to limit computations that can happen at line rate. Further,
while NetASM's dataflow framework focuses only on target-independent middle-end
optimizations such as dead-code elimination, the \pktlanguage compiler
implements a compiler back-end for line-rate switches
(\S\ref{ss:code_gen}).

\textbf{Programmable data planes:}
Software data planes such as Click~\cite{click},
RouteBricks~\cite{routebricks}, and Fastpass~\cite{fastpass} are flexible but
lack the performance required for large-scale deployments. Network
Processors~\cite{ixp2800, ixp4xx} (NPUs) were an attempt to bridge the gap.
NPUs are faster than software routers; yet, they remain
\textasciitilde10$\times$ slower than switching chips~\cite{rmt}.

Eden~\cite{eden} provides a programmable data plane using commodity switches by
programming end hosts alone. \pktlanguage targets programmable switches that
increase the scope of programmable data planes relative to an end-host-only
solution. For instance, \pktlanguage permits us to express in-network
congestion control, AQM, and congestion-aware load balancing (CONGA), which are
beyond Eden's capabilities. Tiny Packet Programs (TPP)~\cite{tpp} allow end
hosts to embed small programs in packet headers, which are then executed by the
switch. TPPs are written in a restricted instruction set to facilitate switch
execution; we show that switch instructions must and can be substantially
richer (Table~\ref{tab:templates}) to support stateful data-plane algorithms.

An alternative is to use FPGAs; examples include NetFPGA~\cite{netfpga},
Switchblade~\cite{switchblade}, and Chimpp~\cite{chimpp}.  These designs are
slower than switching ASICs, and are rarely used in production network
equipment. The Arista 7124 FX~\cite{7124fx} is a commercial switch with an
on-board FPGA, but its capacity is limited to 160 Gbits/sec when using the
on-board FPGA---10$\times$ less than the multi-terabit capacities of programmable
switch chips~\cite{xpliant}.

Jose et al.~\cite{lavanya_compiler} focus on compiling P4 programs to
programmable data planes such as the RMT and FlexPipe architectures. Their work
focuses on compiling stateless data-plane tasks such as forwarding and routing,
while \pktlanguage focuses on stateful data-plane algorithms.

\textbf{Packet-processing languages:}
Many programming languages target the network control plane. Examples include
Frenetic~\cite{frenetic}, Pyretic~\cite{pyretic}, and Maple~\cite{maple}.
\pktlanguage focuses on the data plane.

Several DSLs target the data-plane. Click~\cite{click} uses C++ for packet
processing on software routers. NOVA~\cite{nova}, packetC~\cite{packetc},
Intel's auto-partitioning C compiler~\cite{intel_uiuc_pldi},
PacLang~\cite{paclang_lang, paclang_partitioner}, and Microengine
C~\cite{microenginec, intel_ixa} target network processors~\cite{ixp2800,
ixp4xx}. \pktlanguage's C-like syntax and sequential semantics are inspired by
these DSLs. However, by targeting line-rate switches, \pktlanguage is more
constrained: e.g., it forbids loops and includes no synchronization constructs
because there is no shared state in \absmachine machines.

The SNAP~\cite{snap} system programs stateful data-plane algorithms using a
network transaction: an atomic block of code that treats the entire network as
one switch~\cite{onebigswitch} and uses a compiler to translate network
transactions into rules on each switch. SNAP doesn't compile these switch-local
rules into a switch's pipeline. \pktlanguage can be used to compile SNAP's
switch-local rules to an atom pipeline and is an enabler for SNAP and other
network-wide abstractions. FAST~\cite{fast} is a system that provides switch
support and software abstractions for state machines. \absmachine's atoms
support more general stateful processing beyond state machines that enable
a much wide class of data-plane algorithms.
