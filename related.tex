\section{Related work}
\label{s:related}
%TODO: opendataplane.org
\textbf{Data-Plane Algorithms}
Several data-plane algorithms are now commonplace, e.g., lookup algorithms based
on longest-prefix, exact, or ternary matches.  \pktlanguage focuses on
data-plane algorithms that aren't widely available because of the engineering
effort required for hardware implementations.  Further, the growing list of new
algorithms~\cite{pdq, d3, detail, codel, conga} makes it hard to commit to a
hardware implementation. \pktlanguage allows network programmers to modify
these algorithms more rapidly.

\textbf{Abstract machines for line-rate switches}
Relative to P4's abstract switch model~\cite{p4}, \absmachine contributes the
notions of atoms, sequential execution within atoms, and state encapsulated by
atoms. Closest to \absmachine is NetASM~\cite{netasm}, an intermediate
representation and abstract machine for programmable data planes.  \absmachine
differs from NetASM by explicitly targeting line-rate switches in two ways.
First, all state in \absmachine is internal to an atom (and hence a stage),
while NetASM's ATM construct allows access to shared state from multiple
pipeline stages. Second, \absmachine uses atom templates to limit the amount of
useful work that can be performed in an atom.

\textbf{Programmable Data Planes}
Software-based data planes such as Click~\cite{click},
RouteBricks~\cite{routebricks}, and Fastpass~\cite{fastpass} are flexible but
lack the performance required for deployments. Network
Processors~\cite{ixp2800, ixp4xx} (NPUs) were an attempt to bridge the gap.
While NPUs are faster than software routers, they remain an order of magnitude
slower than merchant silicon chips~\cite{rmt}.
%and have not found success in the
%market~\cite{npfail}.

An alternative is to use FPGAs to improve performance relative to software
routers and NPUs; examples include NetFPGA~\cite{netfpga},
Switchblade~\cite{switchblade}, Chimpp~\cite{chimpp}, and~\cite{silver_bullet}.
These designs are slower than switching ASICs, and are rarely used in
production network equipment. The Arista 7124 FX~\cite{7124fx} is a commercial
switch with an on-board FPGA, but its capacity is limited to 160 Gbits/sec when
using the on-board FPGA---~10x less than the multi-terabit capacities of
programmable switch chips~\cite{xpliant}. In addition, FPGAs are hard to
program. Relative to FPGAs, \pktlanguage seeks to provide both the line-rate
performance of switching ASICs and a familiar programming model.

\textbf{Packet-processing languages}
Many programming languages target the network control plane. Examples include
Frenetic~\cite{frenetic}, Pyretic~\cite{pyretic}, and
Maple~\cite{maple}.~\cite{language_survey} is a survey of such approaches.  In
contrast, \pktlanguage focuses on the data plane. Several DSLs explicitly
target data-plane packet processing. Click~\cite{click} uses C++ for packet
processing on software routers. Imperative languages such as NOVA~\cite{nova},
packetC~\cite{packetc}, Intel's auto-partitioning C
compiler~\cite{intel_uiuc_pldi}, PacLang~\cite{paclang_lang,
paclang_partitioner}, and Microengine C~\cite{microenginec, intel_ixa} target
network processors~\cite{ixp2800, ixp4xx}.
%PX~\cite{PX}
%is a language that targets packet processing on FPGA platforms.

\pktlanguage's C-like syntax and sequential semantics are inspired by these
languages. However \pktlanguage is constrained relative to its predecessors:
for instance, it forbids loops and includes no synchronization constructs
because all state is internal to an atom. These constraints were chosen to
target line-rate switching chips with shared-nothing memory architectures. As a
result, \pktlanguage's compiler presents a different programming model: all
\pktlanguage programs that compile run at line-rate, while those that can't run
at line rate are rejected outright. Unlike an NPU or software router, there is
no slippery slope of degrading performance with increasing program complexity.

P4~\cite{p4} is an emerging packet-processing language that explicitly targets
line-rate programmable switching chips. However, while P4 is a natural model
for many header-manipulation tasks such as switching, ACLs, routing, and
tunnelling~\cite{dc_p4}, it is ill-suited to programming data-plane algorithms that
rely on intricate state manipulation.

% TODO: Compare and contrast against NetASM.
% TODO: Streamline related work discussion considerably.
% TODO: Compare against SNAP from Princeton.
% -- We provide the stateful API that enables SNAP.
% -- For some algorithms, a network-wide approach is untenable.
% TODO: Compare against Hitesh Ballani's Eden work from MSR
% -- Provides programmability through end-hosts, not within the network
