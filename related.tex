\section{Related work}
\label{s:related}
\textbf{Abstract machines for line-rate switches:}
NetASM~\cite{netasm} is an abstract machine and intermediate representation
(IR) for programmable data planes that is portable across network
devices: FPGAs, virtual switches, and line-rate switches.  \absmachine is a
low-level machine model for line-rate switches alone and can be used as a
NetASM target. Because of its role as a low-level machine model, \absmachine
models practical constraints required for line-rate operation (\S\ref{s:atomConstraints}) that an IR like
NetASM doesn't have to. For instance, \absmachine machines don't permit sharing
state between atoms and use atom templates to limit computations that can
happen at line rate.

%Further, while NetASM's dataflow framework
%focuses only on target-independent middle-end optimizations such as dead-code
%elimination, the \pktlanguage compiler implements a compiler back-end for
%line-rate switches (\S\ref{ss:code_gen}).

\textbf{Programmable data planes:}
Eden~\cite{eden} provides a programmable data plane using commodity switches by
programming end hosts alone. \pktlanguage targets programmable switches that
provide more flexibility relative to an end-host-only solution. For instance,
\pktlanguage allows us to program in-network congestion control and AQM
schemes, which are beyond Eden's capabilities.  Tiny Packet Programs
(TPP)~\cite{tpp} allow end hosts to embed small programs in packet headers,
which are then executed by the switch. TPPs use a restricted instruction set to
facilitate switch execution; we show that switch instructions must and can be
substantially richer (Table~\ref{tab:templates}) for stateful data-plane
algorithms.

Software routers~\cite{click, routebricks} and network processors~\cite{ixp4xx}
are flexible, but at least 10$\times$--100$\times$ slower than programmable
switches~\cite{xpliant, tofino}.  FPGA-based platforms like the Corsa DP
6440~\cite{corsa}, which supports an aggregate capacity of 640 Gbit/s, are
faster, but still 5$\times$--10$\times$ slower than programmable
switches~\cite{xpliant, tofino}.

\textbf{Packet-processing languages:} Many programming languages~\cite{frenetic, maple} target the network control plane.
\pktlanguage focuses on the data plane instead, which requires different
programming constructs and compilation techniques.

Several DSLs target the data-plane. Click~\cite{click} uses C++ for packet
processing on software routers. packetC~\cite{packetc}, Intel's
auto-partitioning C compiler~\cite{intel_uiuc_pldi}, and Microengine
C~\cite{microenginec} target network processors. \pktlanguage's C-like syntax
and sequential semantics are inspired by these DSLs. However, because it targets
line-rate switches, \pktlanguage is more constrained, e.g., because it ensures
that compiled programs can run at line rate, the language forbids loops and
includes no synchronization constructs as \absmachine has  no shared state.

Jose et al.~\cite{lavanya_compiler} focus on compiling P4 programs to
programmable data planes such as the RMT and FlexPipe architectures. Their work
focuses only on compiling stateless data-plane tasks such as forwarding and
routing, while \pktlanguage handles stateful data-plane algorithms.

SNAP~\cite{snap} programs stateful data-plane algorithms using a network
transaction: an atomic block of code that treats the entire network as one
switch~\cite{onebigswitch}. It then uses a compiler to translate network
transactions into rules on each switch. SNAP doesn't compile these switch-local
rules into a switch's pipeline. \pktlanguage can be used to compile SNAP's
switch-local rules to an atom pipeline.

FAST~\cite{fast} provides switch
support and software abstractions for state machines. \absmachine's atoms
support more general stateful processing beyond state machines that enable a
much wider class of data-plane algorithms.
