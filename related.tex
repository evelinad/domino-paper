\section{Related work}
\label{s:related}
%TODO: opendataplane.org
\textbf{Data-Plane Algorithms}
Several data-plane algorithms are now commonplace, e.g. lookup algorithms based
on longest-prefix, exact, or ternary matches.  \pktlanguage focuses on
data-plane algorithms that aren't widely available because of the engineering
effort required for hardware implementations.  Further, the growing list of new
algorithms~\cite{pdq, d3, detail, codel, conga} makes it hard to commit to a
hardware implementation. \pktlanguage allows network programmers to modify
these algorithms more rapidly.

\textbf{Abstract machines for line-rate switches}
Relative to P4's abstract switch model~\cite{p4}, \absmachine contributes the
notions of atoms, sequential execution within atoms, and state encapsulated by
atoms. Closest to \absmachine is NetASM~\cite{netasm}, an intermediate
representation and abstract machine for programmable data planes.  \absmachine
differs from NetASM by explicitly targeting line-rate switches in two ways.
First, all state in \absmachine is internal to an atom (and hence a stage),
while NetASM's ATM construct allows access to shared state from multiple
pipeline stages. Second, \absmachine uses atom templates to limit the amount of
useful work that can be performed in an atom.

\textbf{Programmable Data Planes}
Software-based data planes such as Click~\cite{click},
RouteBricks~\cite{routebricks}, and Fastpass~\cite{fastpass} are flexible but
lack the performance required for deployments. Network
Processors~\cite{ixp2800, ixp4xx} (NPUs) were an attempt to bridge the gap.
While NPUs are faster than software routers, they remain an order of magnitude
slower than merchant silicon chips~\cite{rmt}.
%and have not found success in the
%market~\cite{npfail}.

An alternative is to use FPGAs to improve performance relative to software
routers and NPUs; examples include NetFPGA~\cite{netfpga},
Switchblade~\cite{switchblade}, Chimpp~\cite{chimpp}, and~\cite{silver_bullet}.
These designs are slower than switching ASICs, and are rarely used in
production network equipment. The Arista 7124 FX~\cite{7124fx} is a commercial
switch with an on-board FPGA, but its capacity is limited to 160 Gbits/sec when
using the on-board FPGA---~10x less than the multi-terabit capacities of
programmable switch chips~\cite{xpliant}. In addition, FPGAs are hard to
program. Relative to FPGAs, \pktlanguage seeks to provide both the line-rate
performance of switching ASICs and a familiar programming model.

\textbf{Packet-processing languages}
Many programming languages target the network control plane. Examples include
Frenetic~\cite{frenetic}, Pyretic~\cite{pyretic}, and
Maple~\cite{maple}.~\cite{language_survey} is a survey of such approaches.  In
contrast, \pktlanguage focuses on the data plane. Several DSLs explicitly
target data-plane packet processing. Click~\cite{click} uses C++ for packet
processing on software routers. Imperative languages such as NOVA~\cite{nova},
packetC~\cite{packetc}, Intel's auto-partitioning C
compiler~\cite{intel_uiuc_pldi}, PacLang~\cite{paclang_lang,
paclang_partitioner}, and Microengine C~\cite{microenginec, intel_ixa} target
network processors~\cite{ixp2800, ixp4xx}.
%PX~\cite{PX}
%is a language that targets packet processing on FPGA platforms.

\pktlanguage's C syntax and sequential semantics are inspired by these
languages. However \pktlanguage is constrained relative to its predecessors:
for instance, it forbids loops and includes no synchronization constructs
because all state is internal to an atom. These constraints were chosen to
target line-rate switching chips with deterministic performance and
shared-nothing memory architectures. As a result, \pktlanguage's compiler
presents a different programming model: all \pktlanguage programs that compile
run at line-rate, while those that can't run at line rate are rejected
outright. There is no slippery slope of degrading performance with increasing
program complexity.

P4~\cite{p4} is an emerging packet-processing language that explicitly targets
line-rate programmable switching chips. However, while P4 is a natural model
for many header-manipulation tasks such as switching, ACLs, routing, and
tunelling, it is presently ill suited to programming data-plane algorithms that
rely on intricate state manipulation.

\textbf{Compiler Techniques}
\pktlanguage's compiler uses three-address codes~\cite{tac}, static-single
assignment form~\cite{ssa}, and if conversion~\cite{if_conversion} from the
compiler literature. However, \pktlanguage's constrained design allows us to
simplify these techniques relative to their mainstream uses.  The use of
strongly connected components is based on similar uses in software
pipelining~\cite{software_pipelining} for VLIW architectures. However,
dependence analysis for loop-carried dependencies in software pipelining
(equivalent to state in \pktlanguage) is more involved than the simple
syntactic checks used by \pktlanguage. The use of synthesis to map codelets to
atoms is based on Chlorophyll's~\cite{chlorophyll} use of program synthesis for
compilation to unconventional targets.

\textbf{Hardware compilation}
Prior work ~\cite{nurvadathi, cash, bluespec} has focused on deriving digital
circuits from imperative programs. These approaches simplify hardware
development, but the performance of each program depends on its complexity.
\pktlanguage has an all-or-nothing guarantee: all code that compiles can run at
line rate or is rejected by the compiler.  Mapping from codelets to atoms is
similar to technology mapping~\cite{micheli, flowmap, spectransform}, where a
target hardware circuit (represented as a graph) is implemented by tiling the
circuit graph with primitive circuits from a technology library. \pktlanguage's
problem is simpler. We only need to verify if a codelet maps to an atom---not
implement a codelet using multiple atoms.  Recent work~\cite{lavanya_compiler}
focuses on compiling P4 programs to hardware targets such as the RMT and
FlexPipe architectures. However, their work focuses on compiling stateless
data-plane tasks such as forwarding and routing, while \pktlanguage focuses on
stateful data-plane algorithms.
