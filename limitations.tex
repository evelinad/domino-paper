\section{Limitations and Future Work}
\label{s:limitations}

\textbf{Limitations}
While \pktlanguage's compiler guarantees correctness, it doesn't attempt
optimality.  Specifically, \pktlanguage doesn't reduce or consolidate the
number of temporaries it creates. By flattening all statements to three-operand
code form, it doesn't take advantage of more powerful atoms that might be
available in the \absmachine instance. By mapping stateful codelets to stateful
atoms one-to-one, it doesn't take advantage of more powerful atoms, such as the
paired update atom, which could express the operations of two stateful codelets
in one atom.

This increases the width and depth of the resulting pipeline. For instance,
redundant stateless atoms that compute the same value twice in the same stage increase
the pipeline width. Similarly, consider a data-plane algorithm such as a heavy
hitter detection with $k$ hash functions. This results in $k$ stateful codelets
with no dependencies between themselves, each of which increments a state
variable. If a paired update atom was available, these $k$ stateful codelets
could be consolidated into $\frac{k}{2}$ atoms, each of which operated on a
pair of state variables. Mapping stateful codelets to atoms one-to-one misses
this opportunity and increases the width of the pipeline by creating additional
stateful atoms. Similarly, expression flattening could cause an additional stage,
where one stage would have sufficed, increasing the pipeline depth in the process.

We plan to address these suboptimalities by incorporating both standard
compiler optimizations such as common subexpression elimination, copy
propagation, and dead code elimination, and techniques such as
superoptimization~\cite{stoke, superoptimizer} that explicitly target optimal
code.

The \pktlanguage compiler currently only handles a single packet transaction
running on the abstract machine.  Extending \pktlanguage and its compiler to
handle multiple interacting packet transactions is another area of future work.

% Anirudh->Hari: Do you buy this?
Lastly, \pktlanguage doesn't yet generate code for actual hardware. We
initially considered compiling \pktlanguage to P4, but decided against it
because P4 currently doesn't support sequential execution within a
pipeline stage---required to correctly execute the codelets/atoms produced by
\pktlanguage. Based on this work, we have submitted a proposal for sequential
execution~\cite{p4-semantics} to the P4 language consortium. In the future, if
P4 supports sequential execution, \pktlanguage could target P4 as a backend,
which would then allow \pktlanguage to compile to programmable switches by
leveraging ongoing work~\cite{netronome, xilinx,lavanya_compiler} in compiling
P4 to hardware targets.

\textbf{Future Work}
Currently, \pktlanguage rejects programs that don't compile with an error
message.  In the future, we plan to improve upon this by automatically
suggesting ways in which the user could approximate the program so that it
could compile. We imagine doing this in two ways. First, \pktlanguage could
suggest ways to simplify a codelet that doesn't map so that it does map.
Second, we could use primitives such as P4's recirculate
primitive~\cite{p4spec} to send a packet back into the switch pipeline if the
packet requires more processing than is available in one traversal of the
switch pipeline. Reasoning about the semantics of these
approximations~\cite{sampsonApprox, chisel} is also another area for future
work.

We also plan to enhance the \pktlanguage language by providing a stronger type
system, type inference, user-defined functions and types, and language
constructs for match-action tables. Another area of future work is looking at
whether \pktlanguage can be used (or extended) to express data-plane algorithms
such as scheduling, active queue management, and buffer-management
schemes~\cite{broadcom_buffer}.
