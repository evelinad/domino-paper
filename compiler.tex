\section{The \pktlanguage compiler}
\label{s:compiler}

\begin{figure*}[!t]
  \includegraphics[width=\textwidth]{compiler.pdf}
  \caption{Passes in the \pktlanguage compiler}
  \label{fig:passes}
\end{figure*}

\begin{figure*}[!t]
  \hspace{-0.3in}
  \begin{minipage}{0.55\textwidth}
  \begin{small}
  \begin{lstlisting}[style=customc, numbers=none, frame=none]
  if (@\textcolor{blue}{pkt.arrival - last\_time[pkt.id] > THRESHOLD}@) {
    saved_hop[pkt.id] = pkt.new_hop;
  }
  \end{lstlisting}
  \end{small}
  \end{minipage}
%  
  \hspace{-0.5in}
  $\Longrightarrow$ 
  \hspace{-0.3in}
%  
  \begin{minipage}{0.6\textwidth}
  \begin{small}
  \begin{lstlisting}[style=customc, numbers=none, frame=none]
  @\textcolor{blue}{pkt.tmp = pkt.arrival - last\_time[pkt.id]  > THRESHOLD}@;
  saved_hop[pkt.id] = @\textcolor{magenta}{// Rewritten}@
    @\textcolor{blue}{pkt.tmp}@ ? pkt.new_hop : saved_hop[pkt.id];
  \end{lstlisting}
  \end{small}
  \end{minipage}
\vspace{-.2in}
\caption{Conversion to straight-line code}
\label{fig:if_convert}
\end{figure*}

\begin{figure*}[!t]
  \begin{minipage}{0.43\textwidth}
  \begin{small}
  \begin{lstlisting}[style=customc, numbers=none, frame=none]
pkt.id = hash2(pkt.sport,
               pkt.dport)
         % NUM_FLOWLETS;
...
@\textcolor{blue}{last\_time[pkt.id] = pkt.arrival;}@
...
  \end{lstlisting}
  \end{small}
  \end{minipage}
%  
  \hspace{-0.5in}
  $\Longrightarrow$ 
  \hspace{-0.2in}
%  
  \begin{minipage}{0.61\textwidth}
  \begin{small}
  \begin{lstlisting}[style=customc, numbers=none, frame=none]
pkt.id = hash2(pkt.sport,           @\textcolor{magenta}{// Read flank}@
               pkt.dport)
         % NUM_FLOWLETS;
pkt.last_time = last_time[pkt.id];  @\textcolor{magenta}{// Read flank}@
...
@\textcolor{blue}{pkt.last\_time = pkt.arrival;}@             @\textcolor{magenta}{// Rewritten}@
...
last_time[pkt.id] = pkt.last_time;  @\textcolor{magenta}{// Write flank}
  \end{lstlisting}
  \end{small}
  \end{minipage}
  \caption{Adding read and write flanks}
\label{fig:stateful_flanks}
\end{figure*}

\begin{figure*}[!t]
  \begin{minipage}{\textwidth}
  \begin{minipage}{0.4\textwidth}
  \begin{small}
  \begin{lstlisting}[style=customc, numbers=none, frame=none]
@\textcolor{blue}{pkt.id}@ = hash2(pkt.sport,
              pkt.dport)
              % NUM_FLOWLETS;
@\textcolor{blue}{pkt.last\_time}@ = last_time[@\textcolor{blue}{pkt.id}@];
...
@\textcolor{blue}{pkt.last\_time}@ = pkt.arrival;
last_time[@\textcolor{blue}{pkt.id}@] = @\textcolor{blue}{pkt.last\_time}@;
  \end{lstlisting}
  \end{small}
  \end{minipage}
 % 
  %\hspace{-0.1in}
  $\Longrightarrow$
  \hspace{-0.2in}
%
  \begin{minipage}{0.6\textwidth}
  \begin{small}
  \begin{lstlisting}[style=customc, numbers=none, frame=none]
@\textcolor{blue}{pkt.id0}@ = hash2(pkt.sport,          @\textcolor{magenta}{// Rewritten}@ @\label{line:assign}@
               pkt.dport)
               % NUM_FLOWLETS;  
@\textcolor{blue}{pkt.last\_time0}@ = last_time[@\textcolor{blue}{pkt.id0}@];  @\textcolor{magenta}{// Rewritten}@
...
@\textcolor{blue}{pkt.last\_time1}@ = pkt.arrival;        @\textcolor{magenta}{// Rewritten}@
last_time[@\textcolor{blue}{pkt.id0}@] = @\textcolor{blue}{pkt.last\_time1}@;  @\textcolor{magenta}{// Rewritten}@
  \end{lstlisting}
  \end{small}
  \end{minipage}
  \caption[title]{SSA transformation. Note that all assignments are renamed as they can be preceded by reads.}
  \label{fig:ssa}
\end{minipage}
\end{figure*}


\begin{figure*}[!t]
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=customc]
pkt.id            = hash2(pkt.sport, pkt.dport) % NUM_FLOWLETS; @\label{line:id}@
pkt.saved_hop     = saved_hop[pkt.id]; @\label{line:stateRead}@
pkt.last_time     = last_time[pkt.id];
pkt.new_hop       = hash3(pkt.sport, pkt.dport, pkt.arrival) % NUM_HOPS; @\label{line:newhop}@
pkt.tmp           = pkt.arrival - pkt.last_time;
pkt.tmp2          = pkt.tmp > THRESHOLD;
pkt.next_hop      = pkt.tmp2 ? pkt.new_hop : pkt.saved_hop;
saved_hop[pkt.id] = pkt.tmp2 ? pkt.new_hop : pkt.saved_hop; @\label{line:stateWrite}@
last_time[pkt.id] = pkt.arrival;
\end{lstlisting}
\caption[title2]{Flowlet switching in three-address
code. Lines~\ref{line:id} and \ref{line:newhop} are flipped relative
to Figure~\ref{fig:flowlet_code} because {\tt pkt.id} is an array index expression and is
moved into the read flank.}
\label{fig:three_address}
\end{minipage}
\vspace{-0.5cm}
\end{figure*}

The \pktlanguage compiler borrows many techniques from the compiler literature.
The \absmachine architecture, however, poses unique challenges for compilation
requiring a synthesis of techniques that, to the best of our knowledge, is
novel. Further, as we illustrate throughout this section, constraining
\pktlanguage for deterministic performance simplifies the \pktlanguage
compiler relative to mainstream compilers for imperative languages.

Because \pktlanguage's syntax is a subset of C, we use Clang's library
interface~\cite{libclang} to parse and implement the passes in the compiler.
The overall architecture of the compiler is shown in Figure~\ref{fig:passes}.
Throughout this section, we use flowlet switching from
Figure~\ref{fig:flowlet_code} as a running example to demonstrate compiler
passes.  While we have simplified the code for readability, the code output by
the \pktlanguage compiler after each pass isn't materially different from the
version presented here.

\subsection{If-conversion to straight-line code}

A packet transaction's body can contain (potentially nested) conditional
statements (e.g., Lines~\ref{line:ifStart} to \ref{line:ifEnd} in
Figure~\ref{fig:flowlet_code}, or CoDel~\cite{codel_code}). These statements
alter control flow and complicate dependence analysis between statements i.e.
whether a statement should follow or precede another.  We eliminate such
statements by transforming them into the ternary conditional operator, starting
from the innermost if statements and recursing outwards
(Figure~\ref{fig:if_convert}). This procedure is known as
if-conversion~\cite{if_conversion}. Unlike traditional languages, performing
if-conversion in \pktlanguage is easy as there is no unstructured control
flow.  If conversion turns the body of packet transactions into
straight-line code, where control passes sequentially without branching.
Straight-line code simplifies the rest of the compiler, like computing the
static single-assignment form(\S\ref{ss:ssa}).

\subsection{Rewriting state variable operations} %Converting to load/store form}
\label{ss:load/store}

We next identify both array and scalar state variables used in a packet
transaction, such as \texttt{last\_time} and \texttt{saved\_hop} in
Figure~\ref{fig:flowlet_code}. State variables are easy to identify
syntactically, since all variables are either packet fields or state variables.
For each state variable, we create a \textit{read flank} to read the state
variable into a temporary packet field. For an array, we also move the index
expression into the read flank, exploiting the fact that only one array index
is accessed by each packet in valid \pktlanguage programs.  Then, throughout
the packet transaction, we replace the state variable with the packet
temporary, and create a \textit{write flank} to write the packet temporary back
into the state variable.  Figure~\ref{fig:stateful_flanks} illustrates this
transformation.  After this pass, the code resembles code for a load-store
architecture~\cite{load_store}: all state variables must be loaded into packet
variables before arithmetic can be performed on them.  Restricting operations on state
variables simplifies subsequent code partitioning (\S\ref{ss:partitioning}).

\subsection{Converting to single-assignment form}
\label{ss:ssa}

We next convert the code to static single-assignment form (SSA), as shown in
Figure~\ref{fig:ssa}). In SSA form, every variable is assigned exactly once. To
compute the SSA, we replace every definition of a packet variable with a new
packet variable and propagate this new variable until the next definition of
the same variable. State variables are already in SSA: after their flanks have
been added, every state variable is written exactly once in the write flank.
While general algorithms for computing the SSA are fairly involved~\cite{ssa},
\pktlanguage's SSA computation is simpler because it runs after if conversion
and hence operates on straight-line code.  Because every variable is assigned
exactly once, SSA removes Write-After-Read and Write-After-Write dependencies.
Only Read-After-Write dependencies remain, simplifying dependency analysis
during code partitioning (\S\ref{ss:partitioning}). We execute copy
propagation~\cite{copy_prop} after SSA to reduce the number of temporary
packet variables.

\subsection{Flattening to three-address code}

The input is next converted to three-address code~\cite{tac}, where all
instructions are either reads / writes into state variables or operations on
packet variables of the form \texttt{pkt.f1 = pkt.f2 op pkt.f3;} where
\texttt{op} can be a conditional,\footnote{Ternary/Conditional operators take
in 4 addresses instead of 3.} arithmetic, logical, or relational operator.
We also allow either one of {\tt pkt.f2} or {\tt pkt.f3} to be an intrinsic
function call.  All expressions that are not already in three-address code
are flattened by introducing temporaries as illustrated in
Figure~\ref{fig:three_address}.  While flattening expressions may result in
redundant temporaries that compute the same subexpression, we remove such temporaries
 using common subexpression elimination~\cite{cse}.

\subsection{Code partitioning to codelets}
\label{ss:partitioning}
At this point, the code is still sequential. Code partitioning turns sequential
code into a pipeline of \textit{codelets}, where each codelet is a small
sequential block of three-address code statements. Each codelet is then mapped
to an atom provide by a particular \absmachine machine~(\S\ref{ss:code_gen}),
or an error is returned if it cannot be mapped.

To partition code into codelets, we carry out the following steps:
\begin{CompactEnumerate}
  \item Create a node for each statement (Figure~\ref{fig:three_address}) in
    the packet transaction after expression flattening.
  \item Create a bidirectional edge between nodes N1 and N2, where N1 is a read from a
    state scalar / state array and N2 is a write into the same variable.
    This step captures the constraint that state is internal to an
    atom in \absmachine.
  \item Create an edge (N1, N2) for every pair of nodes N1, N2 where N2 reads a
    variable written by N1. We only check read-after-write dependencies because
    control dependencies turn into data dependencies after if conversion, and
    write-after-read and write-after-write dependencies don't exist in SSA.
  \item Generate strongly connected components (SCCs) of the resulting graph
    (Figure~\ref{fig:partitioning_before}) and condense the SCCs to create a
    directed acyclic graph (DAG) (Figure~\ref{fig:partitioning_after}). This
    step captures the constraint that all operations on a state variable
    must reside within the same atom because state is internal to an atom.
    %as state is distributed across them.
  \item Schedule the resulting DAG using critical path
    scheduling~\cite{crit_path_sched} by creating a new pipeline stage every time
    one operation needs to follow another according to the precedence relationship
    established by the DAG (Figure~\ref{fig:partitioning_after}).
\end{CompactEnumerate}
The resulting codelet pipeline\footnote{We refer to this both as a codelet and
an atom pipeline because codelets map one-to-one atoms (\S\ref{ss:code_gen}).}
shown in Figure~\ref{fig:flowlet_pipeline} implements the flowlet packet
transaction.  Further, the codelets have a stylized form.  Codelets that don't
manipulate state contain exactly one three-address code statement after
expression flattening. Codelets that manipulate state contain at least two
statements: a read from a state variable and a write to a state variable, with
optionally one or more updates to the state variable through packet temporaries
in between.

\begin{figure*}[!t]
\begin{minipage}{0.5\textwidth}
  \includegraphics[width=\columnwidth]{deps.pdf}
  \caption{Dependency before condensing SCCs}
  \label{fig:partitioning_before}
\end{minipage}
%
\vrule\quad
%
\begin{minipage}{0.5\textwidth}
\includegraphics[width=\columnwidth]{scc.pdf}
\caption{Dependency graph after condensing SCCs}
\label{fig:partitioning_after}
\end{minipage}
\end{figure*}

\subsection{Mapping codelets to atoms}
\label{ss:code_gen}
Next, we determine how codelets map one-to-one to atoms provided by the
\absmachine machine. We consider codelets that do and don't manipulate state
separately.

\paragraph{Stateless codelets}
As mentioned, stateless codelets have only one
statement in three-address code form (e.g., any of the unshaded boxes in
Figure~\ref{fig:flowlet_pipeline}). We assume that all
\absmachine machines support stateless atoms that correspond to a single
statement in three-address code. P4's primitives~\cite{p4spec} and RMT's VLIW
action set~\cite{rmt} both resemble this form. Under this assumption,
each such codelet is mapped to an atom provided by the
\absmachine machine. If the \absmachine machine supports stateless atoms beyond
a single three-address code statement, this is still correct, although
suboptimal. For instance, if the \absmachine machine supports a
multiply-and-accumulate atom~\cite{mac}, our approach generates two atoms (one
each for the multiply and accumulate), although one suffices.
% Anirudh->Alvin: It doesn't for a rather sloppy reason.
% We basically assume only stateless atoms are supported.
%\ac{say something
%about it doesn't affect much for the examples we use in the experiment}

\paragraph{Stateful codelets}
Stateful codelets have multi-line bodies that need to execute atomically. For
instance, updating the state variable \texttt{saved\_hop} in
Figure~\ref{fig:flowlet_pipeline} requires a read followed by a conditional
write.  It is not apparent whether such codelets can be mapped to an available
atom. We develop a new technique to determine the implementability of such
stateful codelets, on a \absmachine machine that provides a specific stateful
atom template.

First, each atom template is parameterized, where the parameters determine the
actual functionality provided by the atom.  For instance,
Figure~\ref{fig:alu_diag} shows a hardware circuit that is capable of
performing stateful addition or subtraction, depending on the value of the
constant and which output is selected from the multiplexer.  Its atom template
 is shown in Figure~\ref{fig:alu_in_sketch}, where {\tt choice}
and {\tt constant} represent the tunable parameters.  Each codelet can be
viewed as a functional specification of the atom.  With that in mind, the
mapping problem is equivalent to searching for the value of the parameters to
configure the atom such that it implements the provided specification.

While many algorithms can be used to perform the search, in the \pktlanguage
compiler we use the SKETCH program synthesizer~\cite{sketch_asplos} for this
purpose, as the atom templates can be easily expressed using SKETCH, while
SKETCH also provides efficient search algorithms and has been used for similar
purposes across different domains~\cite{bitstreaming, lifejoin, qbs, chlorophyll}.

As an illustration, assume we want to map the codelet {\tt x=x+1} to the atom
template shown in Figure~\ref{fig:alu_in_sketch}. The \pktlanguage compiler
feeds in the codelet and the atom template into SKETCH
(Figure~\ref{fig:sketch}), and SKETCH will search for possible values of the
parameters such that the resulting atom performs the same functionality as the
codelet, for all possible input values of {\tt x}.  In this case this is done
by setting {\tt choice=0} and {\tt constant=1}.  In contrast, if the codelet
{\tt x=x*x} was supplied as the specification, SKETCH will return an error as
no such parameter value exists. To minimize search time, the range of possible
inputs and parameter values need to be specified in the template (e.g., all 8
bit integers), and our experiments show that the search finishes quickly,
taking 10 secs at most.

\begin{figure}[!b]
  \begin{center}
  \includegraphics[width=0.4\columnwidth]{sketch.pdf}
  \caption{Overview of SKETCH and its application to atom configuration}
  \label{fig:sketch}
  \end{center}
\end{figure}

\begin{figure}[h]
  \begin{minipage}{0.4\columnwidth}
  \begin{center}
  \includegraphics[width=\columnwidth]{circuit.pdf}
  \end{center}
  \caption{Circuit for an atom that can add or subtract a constant from a state variable.}
  \label{fig:alu_diag}
  \end{minipage}
  \hspace{0.05\columnwidth}
  \begin{minipage}{0.55\columnwidth}
  \begin{lstlisting}
  bit choice = ??;
  int constant = ??;
  if (choice) {
    x = x + constant;
  } else {
    x = x - constant;
  }
  \end{lstlisting}
  \caption{Circuit representation as an atom template.}
  %Each ``??(n)'' represents a hole that can be filled in with values in $[0, 2^n -1]$.}
  \label{fig:alu_in_sketch}
  \end{minipage}
\end{figure}

\subsection{Verifying compilations}
\label{ss:verification}

Our testing infrastructure verifies that the compilation is correct. By this,
we mean that the externally visible behavior of the packet transaction
(Figure~\ref{fig:flowlet_code}) is indistinguishable from its pipelined
implementation (Figure~\ref{fig:flowlet_pipeline}). We verify correctness by
feeding in the same set of test packets to both the packet transaction and its
implementation and comparing the outputs from both on the set of externally visible fields.

To create test packets, we scan the packet transaction and generate the set of
all fields read from or written to by the transaction. We initialize each field
by sampling independently and uniformly from the space of all 32-bit signed
integers.  To compare outputs from the packet transaction and its
implementation, we track renames that occur after SSA and compare each output
field in the transactional form with its last rename in the implementation.
This lets us quickly ``spot check'' our compilations and helped us discover a
few compiler bugs during development.

\subsection{Targeting real switches}
\label{ss:real}
\pktlanguage doesn't yet generate code for actual hardware. We considered
compiling \pktlanguage to P4, which would then allow \pktlanguage to target
programmable switches by leveraging ongoing work~\cite{netronome,
xilinx,lavanya_compiler} in P4 compilation. However, P4 currently doesn't
support sequential execution within a pipeline stage or the conditional
operator as a primitive action. Both are required to correctly execute the
codelets/atoms produced by \pktlanguage (Figure~\ref{fig:flowlet_pipeline}).
We have submitted a proposal~\cite{p4-semantics} for both to the P4 language
consortium. The proposal has been tentatively accepted and is likely to be
included in P4 v1.1.

% TODO: Simplify this considerably.
% Also, per George, stress clearly what is new relative to standard compiler techniques.
