\section{The \pktlanguage compiler}
\label{s:compiler}

%TODO: Mihai: Mention how the complex atoms could be used to carry out stateless
%operations as well by reducing the number of stages.
\begin{figure*}[!t]
  \includegraphics[width=\textwidth]{compiler.pdf}
  \caption{Passes in the \pktlanguage compiler}
  \label{fig:passes}
\end{figure*}

\begin{figure*}[!t]
  \hspace{-0.3in}
  \begin{minipage}{0.55\textwidth}
  \begin{small}
  \begin{lstlisting}[style=customc, numbers=none, frame=none]
  if (@\textcolor{blue}{pkt.arrival - last\_time[pkt.id] > THRESHOLD}@) {
    saved_hop[pkt.id] = pkt.new_hop;
  }
  \end{lstlisting}
  \end{small}
  \end{minipage}
%  
  \hspace{-0.5in}
  $\Longrightarrow$ 
  \hspace{-0.3in}
%  
  \begin{minipage}{0.6\textwidth}
  \begin{small}
  \begin{lstlisting}[style=customc, numbers=none, frame=none]
  @\textcolor{blue}{pkt.tmp = pkt.arrival - last\_time[pkt.id]  > THRESHOLD}@;
  saved_hop[pkt.id] = @\textcolor{magenta}{// Rewritten}@
    @\textcolor{blue}{pkt.tmp}@ ? pkt.new_hop : saved_hop[pkt.id];
  \end{lstlisting}
  \end{small}
  \end{minipage}
\vspace{-.2in}
\caption{Conversion to straight-line code}
\label{fig:if_convert}
\end{figure*}

\begin{figure*}[!t]
  \begin{minipage}{0.43\textwidth}
  \begin{small}
  \begin{lstlisting}[style=customc, numbers=none, frame=none]
pkt.id = hash2(pkt.sport,
               pkt.dport)
         % NUM_FLOWLETS;
...
@\textcolor{blue}{last\_time[pkt.id] = pkt.arrival;}@
...
  \end{lstlisting}
  \end{small}
  \end{minipage}
%  
  \hspace{-0.5in}
  $\Longrightarrow$ 
  \hspace{-0.2in}
%  
  \begin{minipage}{0.61\textwidth}
  \begin{small}
  \begin{lstlisting}[style=customc, numbers=none, frame=none]
pkt.id = hash2(pkt.sport,           @\textcolor{magenta}{// Read flank}@
               pkt.dport)
         % NUM_FLOWLETS;
pkt.last_time = last_time[pkt.id];  @\textcolor{magenta}{// Read flank}@
...
@\textcolor{blue}{pkt.last\_time = pkt.arrival;}@             @\textcolor{magenta}{// Rewritten}@
...
last_time[pkt.id] = pkt.last_time;  @\textcolor{magenta}{// Write flank}
  \end{lstlisting}
  \end{small}
  \end{minipage}
  \caption{Adding read and write flanks}
\label{fig:stateful_flanks}
\end{figure*}

\begin{figure*}[!t]
  \begin{minipage}{\textwidth}
  \begin{minipage}{0.4\textwidth}
  \begin{small}
  \begin{lstlisting}[style=customc, numbers=none, frame=none]
@\textcolor{blue}{pkt.id}@ = hash2(pkt.sport,
              pkt.dport)
              % NUM_FLOWLETS;
@\textcolor{blue}{pkt.last\_time}@ = last_time[@\textcolor{blue}{pkt.id}@];
...
@\textcolor{blue}{pkt.last\_time}@ = pkt.arrival;
last_time[@\textcolor{blue}{pkt.id}@] = @\textcolor{blue}{pkt.last\_time}@;
  \end{lstlisting}
  \end{small}
  \end{minipage}
 % 
  %\hspace{-0.1in}
  $\Longrightarrow$
  \hspace{-0.2in}
%
  \begin{minipage}{0.6\textwidth}
  \begin{small}
  \begin{lstlisting}[style=customc, numbers=none, frame=none]
@\textcolor{blue}{pkt.id0}@ = hash2(pkt.sport,          @\textcolor{magenta}{// Rewritten}@ @\label{line:assign}@
               pkt.dport)
               % NUM_FLOWLETS;  
@\textcolor{blue}{pkt.last\_time0}@ = last_time[@\textcolor{blue}{pkt.id0}@];  @\textcolor{magenta}{// Rewritten}@
...
@\textcolor{blue}{pkt.last\_time1}@ = pkt.arrival;        @\textcolor{magenta}{// Rewritten}@
last_time[@\textcolor{blue}{pkt.id0}@] = @\textcolor{blue}{pkt.last\_time1}@;  @\textcolor{magenta}{// Rewritten}@
  \end{lstlisting}
  \end{small}
  \end{minipage}
  \caption[title]{SSA transformation. Note that all assignments are renamed as they can be preceded by reads.}
  \label{fig:ssa}
\end{minipage}
\end{figure*}


\begin{figure*}[!t]
\begin{minipage}{\textwidth}
\begin{lstlisting}[style=customc]
pkt.id            = hash2(pkt.sport, pkt.dport) % NUM_FLOWLETS; @\label{line:id}@
pkt.saved_hop     = saved_hop[pkt.id]; @\label{line:stateRead}@
pkt.last_time     = last_time[pkt.id];
pkt.new_hop       = hash3(pkt.sport, pkt.dport, pkt.arrival) % NUM_HOPS; @\label{line:newhop}@
pkt.tmp           = pkt.arrival - pkt.last_time;
pkt.tmp2          = pkt.tmp > THRESHOLD;
pkt.next_hop      = pkt.tmp2 ? pkt.new_hop : pkt.saved_hop;
saved_hop[pkt.id] = pkt.tmp2 ? pkt.new_hop : pkt.saved_hop; @\label{line:stateWrite}@
last_time[pkt.id] = pkt.arrival;
\end{lstlisting}
\caption[title2]{Flowlet switching in three-address
code. Lines~\ref{line:id} and \ref{line:newhop} are flipped relative
to Figure~\ref{fig:flowlet_code} because {\tt pkt.id} is an array index expression and is
moved into the read flank.}
\label{fig:three_address}
\end{minipage}
\vspace{-0.5cm}
\end{figure*}

The \pktlanguage compiler borrows many techniques from the compiler
literature~\cite{muchnik}. The \absmachine architecture, however, 
poses unique challenges for compilation.
%Further, as we illustrate
%throughout this section, constraining \pktlanguage for deterministic
%performance has a happy side effect: it simplifies the techniques in
%\pktlanguage's compiler relative to mainstream compilers. 
Since \pktlanguage's syntax is effectively a subset of C, 
we use Clang's library interface~\cite{libclang} to parse and implement
the passes in the compiler. The overall architecture is shown 
in Figure~\ref{fig:passes}. Throughout this section,
we use flowlet switching from Figure~\ref{fig:flowlet_code} as a running
example to demonstrate compiler passes.  While we have simplified the code for
readability, the code output by the \pktlanguage compiler after each pass isn't
materially different from the version presented here.

\subsection{If-conversion to straight-line code}
A packet transaction's body can contain (potentially nested) conditional statements 
(e.g., Lines~\ref{line:ifStart} to \ref{line:ifEnd} in Figure~\ref{fig:flowlet_code},
or CoDel~\cite{codel_code}). These statements alter
control flow and complicate dependence analysis \ac{what dependence analysis?}. 
We eliminate such
statements by transforming them into the ternary conditional operator, starting from
the innermost if statements and recursing outwards
(Figure~\ref{fig:if_convert}). This procedure is known as
if-conversion~\cite{if_conversion}. Unlike traditional languages, performing
if-conversion in \pktlanguage is easy as there is no unstructured control flows.
The conversion effectively turns the body of packet transactions into straight-line code,
where control passes sequentially without branching. As we will see, this 
simplifies the rest of the compiler.
% Straight-line code
%simplifies the rest of the compiler, like computing the static
%single-assignment form(\S\ref{ss:ssa}).

\subsection{Rewriting state variable operations} %Converting to load/store form}
\label{ss:load/store}

We next identify both array and scalar state variables used in a packet
transaction, such as \texttt{last\_time} and \texttt{saved\_hop} in
Figure~\ref{fig:flowlet_code}. State variables are easy to identify
syntactically, since all variables are either packet fields or state
variables. %, because we forbid pointers. 
For each state variable, we
create a \textit{read flank} to read the state variable into a temporary packet
field. For an array, we also move the index expression into the read flank,
exploiting the fact that only one array index is accessed by each packet in
valid \pktlanguage programs.  Then, throughout the packet transaction, we
replace the state variable with the packet temporary, and create a
\textit{write flank} to write the packet temporary back into the state
variable.  Figure~\ref{fig:stateful_flanks} illustrates this transformation.
After this pass, the code resembles code for a load-store
architecture~\cite{load_store}: all state variables must be loaded into packet
variables before they can be operated.
Restricting operations on state
variables simplifies subsequent code partitioning (\S\ref{ss:partitioning}).

\subsection{Converting to single-assignment form} %Renaming variables to SSA}
\label{ss:ssa}

We next convert the code to static
single-assignment form (SSA), as shown in Figure~\ref{fig:ssa}). In SSA form,
every variable is assigned exactly once. To compute the SSA, we replace
every definition of a packet variable with a new packet variable and propagate
this new variable until the next definition of the same variable. State
variables are already in SSA: after their flanks have been added, every state
variable is written exactly once in the write flank.  While general algorithms
for computing the SSA are fairly involved~\cite{ssa}, \pktlanguage's SSA
computation is simpler because it runs after if conversion and hence operates
on straight-line code.  Because every variable is assigned exactly once, SSA
removes Write-After-Read and Write-After-Write dependencies. Only
Read-After-Write dependencies remain, simplifying dependency analysis during
code partitioning (\S\ref{ss:partitioning}). We execute copy
propagation~\cite{copy_prop} after SSA to reduce the incidence of temporary
packet variables.

\subsection{Flattening to three-address code}

The input is next converted to three-address code~\cite{tac}, where all instructions
are either reads / writes into state variables or operations on packet variables
of the form \texttt{pkt.f1 = pkt.f2 op pkt.f3;} where
\texttt{op} can be a conditional,\footnote{Ternary operators take in 4 addresses
instead of 3.} arithmetic, logical, or relational operator.
We also allow either {\tt pkt.f2} or {\tt pkt.f3} to be an intrinsic function call. 
\ac{can both be function calls?} 
All expressions that are not already 
in three-address code are flattened by introducing temporaries as illustrated in
Figure~\ref{fig:three_address}.  While flattening expressions may result in
redundant temporaries that compute the same subexpression, such
temporaries are removed using common subexpression elimination~\cite{cse}.

%For instance, if the t
%wo statements \texttt{x = a * 5 + b;} and \texttt{x = a * 5 + c;} were
%flattened, the subexpression \texttt{a * 5} would be computed by two
%temporaries.
\subsection{Code partitioning to codelets}
\label{ss:partitioning}
At this point, the code is still sequential. Code partitioning turns sequential
code into a pipeline of \textit{codelets}, where each codelet is a small
sequential block of three-address code statements. We do so by exploiting
parallelism within and across pipeline stages in a \absmachine machine.
Subsequently, we map each codelets one-to-one to atoms provided by a particular
\absmachine machine~(\S\ref{ss:code_gen}), returning a compiler error if any
codelet in the algorithm doesn't map to an atom provided by the hardware.

To partition code into codelets, we carry out the following steps:
\begin{CompactEnumerate}
  \item Create a node for each statement (Figure~\ref{fig:three_address}) in
    the packet transaction after expression flattening.
  \item Create a bidirectional edge between nodes N1 and N2 where N1 is a read from a
    state scalar / state array and N2 is a write into the same state scalar /
    state array. This step captures the constraint that state is internal to an
    atom in \absmachine. Because state variables don't occur in any
    instructions besides reads and writes, this suffices to handle state variables.
  \item Create an edge (N1, N2) for every pair of nodes N1, N2 where N2 reads
    a variable written by N1. We only check read-after-write dependencies because
    control dependencies turn into data dependencies after if conversion. Further,
    SSA removes all write-after-read and write-after-write dependencies.
  \item Generate strongly connected components (SCCs) of the resulting graph
    (Figure~\ref{fig:partitioning_before}) and condense the SCCs to to create a directed
    acyclic graph (DAG) (Figure~\ref{fig:partitioning_after}). This step captures the
    constraint that all operations on state variables (read, write, and modify)
    must reside within the same atom because state is local to an atom.
  \item Schedule the resulting DAG using critical path
    scheduling~\cite{crit_path_sched}, creating a new pipeline stage every time
    one operation needs to follow another (Figure~\ref{fig:flowlet_pipeline}).
\end{CompactEnumerate}
At this point, the resulting codelet pipeline
(Figure~\ref{fig:flowlet_pipeline})\footnote{We refer to this both as a codelet
and an atom pipeline because codelets map one-to-one atoms
(\S\ref{ss:code_gen}).} implements the packet transaction.  Further, the
codelets have a stylized form.  Codelets that don't manipulate state contain
exactly one three-address code instruction after expression flattening.
Codelets that manipulate state contain at least two statements: a read from a
state variable and a write to a state variable.  They optionally consist of one
or more updates to the state variable through packet temporaries.

\begin{figure*}[!t]
\begin{minipage}{0.5\textwidth}
  \includegraphics[width=\columnwidth]{deps.pdf}
  \caption{Dependency before condensing SCCs}
  \label{fig:partitioning_before}
\end{minipage}
%
\vrule\quad
%
\begin{minipage}{0.5\textwidth}
\includegraphics[width=\columnwidth]{scc.pdf}
\caption{Dependency graph after condensing SCCs}
\label{fig:partitioning_after}
\end{minipage}
\end{figure*}

\subsection{Mapping a codelet to an atom}
\label{ss:code_gen}
Next, we determine how codelets map one-to-one to atoms provided by the
\absmachine machine. We consider codelets that do and don't manipulate state
separately.

\textbf{Stateless codelets}
Expression flattening generates stateless codelets that each have only one
statement in three-address code form (e.g. any of the unshaded boxes in
Figure~\ref{fig:flowlet_pipeline}). For this paper, we assume that all
\absmachine machines support stateless atoms that correspond to a single
statement in three-address code. P4's primitives~\cite{p4spec} and RMT's VLIW
action set~\cite{rmt} both resemble this form. Under this assumption, mapping a
stateless codelet is simple: each stateless codelet has exactly one
three-address code statement, which is equivalent to an atom provided by the
\absmachine machine. If the \absmachine machine supports stateless atoms beyond
a single three-address code statement, this is still correct, although
suboptimal. For instance, if the \absmachine machine supports a
multiply-and-accumulate atom~\cite{mac}, this approach generates two atoms (one
each for the multiply and accumulate), where one suffices.

\textbf{Stateful codelets}
Stateful codelets have multi-line bodies that need to execute atomically. For
instance, updating the state variable \texttt{saved\_hop} in
Figure~\ref{fig:flowlet_pipeline} requires a read, followed by a conditional write.  It
is not apparent whether these codelets can be mapped to an available atom. We
develop a general technique to determine the implementability of such stateful
codelets, given as input the stateful atom template provided by the \absmachine
machine.

An atom template defines a space of possible computations such as
permissable ALU operations.  The specific computation is selected by
\textit{configuring} the atom. The codelet is a specification that is to be
checked for functional equivalence against one of the atom configurations
supported by the atom template. We need to \textit{synthesize} the atom's
\textit{configuration}, given an \textit{atom template} describing the atom's
functionality.

This is the realm of syntax-guided program synthesis~\cite{sgsyn}, where the
programmer supplies a partial program or template (hence the term
syntax-guided) with missing details, and a specification. A \textit{program
synthesis tool} then synthesizes these details in the partial program so that
it matches up with the specification. One such program synthesis tool is
SKETCH~\cite{bitstreaming, sketch_asplos, sketch_manual}, which allows the
programmer to specify a partial program with \textit{holes} that are then
``filled in'' by SKETCH to match the specification (Figure~\ref{fig:sketch}).

\begin{figure}[!b]
  \begin{center}
  \includegraphics[width=0.4\columnwidth]{sketch.pdf}
  \caption{Overview of SKETCH and its application to atom configuration}
  \label{fig:sketch}
  \end{center}
\end{figure}

\begin{figure}[h]
  \begin{minipage}{0.4\columnwidth}
  \begin{center}
  \includegraphics[width=\columnwidth]{circuit.pdf}
  \end{center}
  \caption{Circuit for an atom that can either add or subtract a constant from a state variable.}
  \label{fig:alu_diag}
  \end{minipage}
  \hspace{0.05\columnwidth}
  \begin{minipage}{0.55\columnwidth}
  \begin{lstlisting}
  bit choice = ??(1);
  int constant = ??(5);
  if (bit) {
    x = x + constant;
  } else {
    x = x - constant;
  }
  \end{lstlisting}
  \caption{Circuit's representation in SKETCH. Each ``??(n)'' represents a hole
  that can be filled in with values in $[0, 2^n -1]$.}
  \label{fig:alu_in_sketch}
  \end{minipage}
\end{figure}

We use SKETCH to solve the atom configuration problem.  Consider an atom
template that models an ALU (Figure~\ref{fig:alu_diag}) taking two
configuration parameters: an opcode, \texttt{choice}, specifying an addition or
subtraction operation, and a 5-bit positive constant, \texttt{constant}.  The
ALU can either add or subtract this constant from one state variable. This ALU
can be represented by the SKETCH partial program given in
Figure~\ref{fig:alu_in_sketch}.

Assume we want to map the codelet x=x+1 to this atom. The codelet is then fed
into SKETCH as the desired specification and the atom template is fed into
SKETCH as the partial program (Figure~\ref{fig:sketch}). SKETCH will configure
the atom template by setting \texttt{choice} to 0 and \texttt{constant} to 1.
In contrast, if the codelet x = x * x was supplied as the specification, SKETCH
will return an error because the specification cannot be mapped to any of the
atom's computations. We don't describe the algorithms underlying SKETCH because
we treat SKETCH as a blackbox in the \pktlanguage compiler. The interested
reader is referred to~\cite{bitstreaming, sketch_asplos} for a more detailed
treatment of these topics.

Using SKETCH to represent atom templates allows us to express the behavior of
diverse atoms (Table~\ref{tab:templates}) using a natural imperative syntax.
Because different \absmachine machines only differ in the atoms they provide,
employing SKETCH for atom configuration lets us build a retargetable
compiler~\cite{lcc} with little target-dependent work beyond specifying each
target's atoms as partial programs in SKETCH.

\subsection{Verifying compilations}
\label{ss:verification}

Our testing infrastructure verifies that the compilation is correct. By this,
we mean that the externally visible behavior of the packet transaction
(Figure~\ref{fig:flowlet_code}) is indistinguishable from its pipelined
implementation (Figure~\ref{fig:flowlet_pipeline}). We verify correctness by
feeding in the same set of test packets to both the packet transaction and its
implementation and comparing the outputs from both programs on the set of
externally visible fields.

To create test packets, we scan the packet transaction and generate the set of
all fields read from or written to by the transaction. We initialize each field
by sampling independently and uniformly from the space of all 32-bit signed
integers.  To compare outputs from the packet transaction and its
implementation, we track renames that occur after SSA and compare each output
field in the transactional form with its last rename in the implementation.
This lets us quickly ``spot check'' our compilations and helped us discover a
few compiler bugs during development.

\subsection{Targeting real switches}
\label{ss:real}
\pktlanguage doesn't yet generate code for actual hardware. We considered
compiling \pktlanguage to P4, which would then allow \pktlanguage to target
programmable switches by leveraging ongoing work~\cite{netronome,
xilinx,lavanya_compiler} in P4 compilation. However, P4 currently doesn't
support sequential execution within a pipeline stage or the conditional
operator as a primitive action. Both are required to correctly execute the
codelets/atoms produced by \pktlanguage (Figure~\ref{fig:flowlet_pipeline}).
We have submitted a proposal~\cite{p4-semantics} for both to the P4 language
consortium. The proposal has been tentatively accepted and looks likely to be
included in P4 v1.1.
