1. Explain why CONGA needs paired updates.
2. Table is too bald.
3. One line of insight as to why CONGA is doable with pairs but not without.
(Sampling: Sampled NetFlow or CISCO sampling).

Exposition:
---------------

1. Figure 2 a seems coerced into a parallel-friendly form.
2. People could use if-else instead.

Cleverness in 4.2:
Refer to CoDel's pseudocode to justify if-conversion as a way of removing the
if else statements.

Minor issues:
----------------
1. Flattening to three-address code (don't break lines).
2. Fit it on one line (widows and ...)

Substantial:
-----------------
Make it very clear what has changed in each transformation.

Figure 5: Adding read and write flanks. Show what actually changed.
Show the read flanks and write flanks in blue.

Add a ... in read and write flanks to show.

Put comment for read flank and write flank to the right of the actual code.

Same idea for SSA.
----------------------
1. It makes no sense if two writes are done one after the other.
2. Put ... in between.
3. Bold the tranformation between the left and right.
4. Use color and ... to teach people what is going on.

Figure 7 flowlet switching
--------------------------
Add a footnote that pkt.id is reordered
because it is an index expression of a read flank.

Everything can be shortened quite a bit.

Atom templates is really wierd to follow in Section 2.
Throw a forward pointer to Figure 10 from Section 2.

Section 3:
-------------------
Too many restrictions in domino.
Can you make them a list of restrictions as a table?
Make it very specific instead of writing a lot of text around it.

Sections:
----------------------
Get rid of 4.1 or simplify it considerably.
Intrinsic functions can be implemented.
Get faster to the good stuff.

2.2 is a little bit more verbose than it could be.

4.3 Just call it "converting to load/store form".


Why is this interesting?
------------------------------
The P4 paper rules out Click, but we show it is possible.
Have something philosophically interesting in the paper
like why this is an interesting model to have.

Table 1
--------------------
Confusing:

There is a little space on the left column.
Write a small comment to explain what each is.
Similar to figure 10.

Just give one example of SKETCH shorthand.
Words aren't precise.

SKETCH looks very intimidating like a job talk.
Add comments to the left column.

Make Table 1 much more dense. Give precise semantics and the commentary.
Table 2: Put the number of stages for each compilation.
(And say we are arguing that it's not optimal).

To drive home the mux notation, in 5.1, For example in mux notation,
Figure 10 would look like (put the code snippet inline).

Controlled redundancy is important to teaching.

Conclusion:
------------------

"Our results suggest that it is possi-
ble to simultaneously have the convenience of high-level
programming and the performance of line-rate switches.
While much work (ยง6) remains before packet transac-
tions can run on real hardware, we hope to have con-
vinced the reader that it is possible."

Mention in the conclusion that its between P4 and Click.

Mention tradeoffs: some can and can't be done.

Verbose text
--------------------

* Abstract is too verbose.
* There is no one line takeaway.
* Introduction could be tightened.

Can you think of examples that Click can do that we can't do?
-------------------------------------------

* Encryption.
* Arbitrary processing on the headers and data in Click.

Clarify what you can't do
----------------------------
* Add either to conclusion (wouldn't mind) or introduction.
* List of restrictions in Section 3
(say that you can't touch the body, encryption).

Intro.tex:
---------------------------
Don't say you need reconfigurability in the field for experimental algorithms.
Nick has three big reasons for reconfigurability.

Just say "prohibits reconfiguration in field to add new functionlity".
Just omit experimental algorithms.

Contributions:
----------------------------
1. You can code in a high-level language.
2. You built a compiler.
3. While you are reusing existing techniques from compilers,
   you are repurposing them to your context.
4. Allows you to quantify this intuitive tradeoff
   between programmability and speed.
   (strength of the atoms is important).
5. Groping towards a quantitative framework for
   the the programmability - performance tradeoff.
6. Theoretically, you could make a programmability - performance tradeoff.
7. Get numbers from Pat on timing.
8. We are beginning to get at a quantitative framework that illustrates the
   tradeoff between programmability and performance, that is very vague in
   people's heads.
9. Beginnings of the quantitative tradeoff between expressivity and speed.
