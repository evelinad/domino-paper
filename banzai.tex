\section{\absmachine: An abstract machine for programmable switches}
\label{s:absmachine}

\begin{figure*}[!t]
  \includegraphics[width=\textwidth]{banzai.pdf}
  \caption{The \absmachine abstract machine and its relationship to
  programmable switch architectures.}
  \label{fig:switch}
\end{figure*}
% deterministic performance or line-rate performance??

We first describe \absmachine, a family of abstract machines that serve as
compiler targets for \pktlanguage. \absmachine is inspired by recent
programmable switch architectures with line-rate performance, such as the
Reconfigurable Match-Action Table (RMT) architecture~\cite{rmt}, Intel's
FlexPipe~\cite{flexpipe} architecture, and Cavium's XPliant Packet
architecture~\cite{xpliant}. These architectures assume the switch model shown
in the top of Figure~\ref{fig:switch}.

Packets arriving to the switch are parsed by a programmable parser that turns
packets into a set of header fields. The set of packet headers is first
processed by an ingress pipeline consisting of match-action tables arranged in
stages. Following the ingress pipeline, the packet is queued, and once it is
dequeued by the switch scheduler, it is processed by a similar egress pipeline
before being transmitted from the switch.

\absmachine models a switch pipeline such as the ingress or egress
pipelines. A pipeline consists of a number of pipeline stages that
execute synchronously on every time step. Each stage is assumed to
have one time step of latency. Once a pipeline stage processes a
packet, it hands it off to the next pipeline stage.

As an abstract machine, \absmachine only models the components that
are critical to mapping data-plane algorithms. In particular, it
models the computation that happens in a match-action table in a stage
(i.e. the action half of the match-action table), but not the match
semantics (e.g., direct, ternary, or longest prefix). \absmachine also
does not model packet parsing and assumes that packets arriving to it
are already parsed.

\subsubsection{Atoms: \absmachine's processing units}

Each pipeline stage contains a vector of \textit{atoms}, with the atoms
executing in parallel. Informally, an atom is an atomic unit of packet
processing provided natively by \absmachine and can be thought of as a body of
imperative code that executes sequentially. An atom is assumed to complete
execution and modify a packet before the next packet is processed by that atom.

An atom may also contain internal state that persists across packets and
influences the atom's behavior from one packet to the next. For instance, a
switch counter could be written as an atom as follows.\footnote{We use the
  notation p.x to represent access to field ``x'' within a packet p and the
  notation x to represent access to the state variable ``x'' that persists across packets}
\begin{verbatim}
  p.tmp     = counter;
  p.tmp2    = p.tmp + 1;
  counter   = p.tmp2;
\end{verbatim}
Similarly, a stateless operation that sets a packet field (such as the
modify\_field action primitive in P4~\cite{p4spec}) can be written as the atom
below:
\begin{verbatim}
  p.field   = value;
\end{verbatim}

\absmachine generalizes several aspects of existing programmable switch
architectures. The vector of atoms in each stage generalizes RMT's very-large
instruction-word (VLIW)~\cite{rmt} that executes primitive actions on
independent packet fields in parallel. The presence of internal state in an
atom models persistent switch state residing on a switch such as meters,
counters, and P4's register abstraction in a unified manner.

\smallskip
\noindent{\bf Constraints on atoms:}
\absmachine assumes a synchronous pipeline where each atom in every pipeline
stage executes on every time step, reading from certain packet fields at the
beginning of the time step and writing to other fields at the end of the time
step. Because all writes happen simultaneously at the end of a time step,
\absmachine forbids two atoms in the same stage from writing to the same
packet field to avoid dealing with data races.

To run at line rate, atoms must be constrained to provide deterministic
performance, to reflect the realities of hardware design. We impose two such
constraints that distinguish \absmachine from software routers such as
Click~\cite{click} and Network Processors such as the Intel IXP~\cite{ixp4xx}
that tradeoff deterministic performance for programmability.

First, \absmachine is a shared-nothing machine: state variables are
internal to a particular atom and their values can only be
communicated with atoms in subsequent stages by writing them into
packet fields that are then read downstream.  This restriction
reflects the capabilities of most switches today: simultaneously
accessing memory from multiple switch stages is technically
challenging because it requires multi-ported RAMs and routing long
wires on the chip.

Second, we constrain the complexity of atoms by defining {\it atom templates}.
Informally, an atom template is a program that is guaranteed to terminate and
specifies how atoms are executed. One template is an in-order CPU that can
execute $N$ instructions, each with a specific format. Another template is an
ALU with a restricted set of primitive operations to choose from. Atom
templates allow us to create specific instances of \absmachine that support
specific computations natively.

These two execution models are not exhaustive: as programmable switches evolve,
we expect the computational capabilities of atoms to evolve as well. However,
atoms cannot be arbitrarily complex: a programmable switch's achievable line
rate is inversely proportional to the worst-case execution latency of its
atoms.
