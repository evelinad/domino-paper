\section{The \pktlanguage compiler frontend}

% for every pass, describe what it is, provide an example, show how it's much
% simpler than usual, and show what invariant it guarantees.
We now describe the \pktlanguage compiler frontend. The compiler frontend
operates only on sequential code blocks, allowing us to borrow well-established
techniques from the compiler literature~\cite{muchnik}. However, as we show
throughout this section, constraining \pktlanguage allows us to considerably
simplify the compiler relative to mainstream compilers.

\subsection{Lexical, syntactic, and semantic analysis}
\pktlanguage's syntax is a subset of C, implying that all \pktlanguage are
well-formed C programs that can be compiled by a C compiler like
clang~\cite{clang}. We use clang's library interface~\cite{libclang} to
generate an Abstract Syntax Tree (AST) for a packet transaction written in
\pktlanguage. The remaining compiler passes all operate on an AST produced by
clang.

Embedding \pktlanguage within C has several benefits. It allows to reuse
clang's industrial strength frontend and catches several compiler errors with
no additional effort.  It also allows us to use C's macro preprocessor for
constants. Finally, opaque functions representing hardware primitives (e.g.
hashes and checksum), can be implemented using arbitrary C code and linked with
\pktlanguage code before running the resulting binary on our abstract machine.

\subsection{Converting to straight-line code}
A packet transaction's body can contain if-else statements that alter the
control flow of the program and complicate dependence analysis. We eliminate
if-else statements by transforming them into the C conditional operator,
starting from the innermost if statements and recursing outwards
(Figure~\ref{fig:if_convert}). This is similar to if
conversion~\cite{allen_if_conversion}, but is much simpler because only the if
and else constructs alter control flow in \pktlanguage and all other forms of
control transfers (break, continue, loops) are forbidden.

We illustrate this on a code fragment from Figure~\ref{fig:flowlet} below:
\begin{figure}
\begin{tiny}
\begin{lstlisting}
if (pkt.arrival_time - last_time[pkt.id1] > FLOWLET_THRESHOLD) {
  saved_hop[pkt.id0] = pkt.new_hop;
}
\end{lstlisting}
\end{tiny}
\begin{center}
is transformed into
\end{center}
\begin{tiny}
\begin{lstlisting}
pkt.tmp0 = pkt.arrival_time - last_time[pkt.id1] > FLOWLET_THRESHOLD;
saved_hop[pkt.id0] = pkt.tmp0 ? pkt.new_hop : saved_hop[pkt.id0];
\end{lstlisting}
\end{tiny}
\caption{Conversion to straight-line code}
\label{fig:if_convert}
\end{figure}

This transformation creates straight-line code, where control always passes
from one statement to the next without any branching. Straight-line code
considerably simplifies the rest of the compiler.

\subsection{Identifying state variables}

We next identify all state variables used in a packet transaction, both arrays
and scalars. State variables represent persistent state stored on the switch
that modifies the behavior of the packet transaction from one step to the next.
In Figure~\ref{fig:flowlet}, \texttt{last\_time} and \texttt{saved\_hop} are
both array-based state variables.

%%We handle state variables differently from packet variables for two reasons.
%%All operations on a particular state variable must happen within one
%%\absmachine atom. This reflects the reality that sharing state variables across
%%atoms or stages is technically challenging because it would require
%%multi-ported memories. Further, all state updates on a state variable should be
%%completed before the next packet is processed. Otherwise, the next packet could
%%see stale values, which would violate the transactional specification.

To identify state variables, we scan the straight-line AST produced by the
previous pass, looking for scalar variables or arrays. For each state variable,
we create a \textit{read flank} to read the state variable into a packet
temporary. For an array, we move the indexing expression into the prologue as
well making use of the fact that the array index remains constant for each
packet for all valid \pktlanguage programs. Next, we replace all occurences of
the state variable with the packet temporary, and create a \textit{write flank}
that writes the packet temporary back into the state variable.  Figure
~\ref{fig:stateful_flanks} illustrates this transformation on a fragment.

\begin{figure}
\begin{tiny}
\begin{lstlisting}
pkt.id1 = hash2(pkt.sport, pkt.dport) \% 8000;
last_time[pkt.id1] = pkt.arrival_time;
\end{lstlisting}
\end{tiny}
\begin{center}
is transformed into
\end{center}
\begin{tiny}
\begin{lstlisting}
// Read prologue for last_time
pkt.id1 = hash2(pkt.sport, pkt.dport) \% 8000;
pkt.last_time0 = last_time[pkt.id1];

pkt.last_time0 = pkt.arrival_time;

// Write epilogue for saved_hop and last_time
last_time[pkt.id1] = pkt.last_time0;
\end{lstlisting}
\end{tiny}
\caption{Adding read and write flanks for state variables}
\label{fig:stateful_flanks}
\end{figure}

At the end of this pass, the code resembles assembly code for a load-store
architecture: state variables are only accessed through reads and writes, and
all arithemtic operations happens on packet variables. Restricting the set of
operations on state variables allows us to simplify reasoning about state
variables when we compile \pktlanguage to the abstract machine
(\S\ref{s:machine}).

% Any reason, we should be running SSA after stateful_flanks and not the
% other way around? Run it and see.
% I tried this in jayhawk and things don't work. Here's why.
% Stateful_flanks almost always destroys SSA because if you have something any
% state variable write of the form s = pkt.f; it will be transformed into
% pkt.tmp = s;
% pkt.tmp = pkt.f;
% s = pkt.tmp;
% which already destroys SSA.

\subsection{Static Single-Assignment Form}
We next transform the code block within the packet transaction into static
single-assignment form (SSA)~\cite{ferrante_ssa}, a well-known intermediate
form used by many compilers where every variable is assigned exactly once.
While computing the SSA in general requires the use of clever graph
algorithms~\cite{post_dominators}, computing the SSA for \pktlanguage is
trivial because the code is in straight-line form by the time SSA is run.

To compute the SSA, we replace every definition of a packet variable with a new
packet variable and propagate this new packet variable until the next
definition of the same variable. State variables are already in SSA form
because after the state flanks have been added, every state variable is read
and written exactly once.

SSA simplifies further analysis. Because every variable is assigned exactly
once, there are no Write-After-Read or Write-After-Write dependencies; only
Read-After-Write dependencies remain. This, in turn, facilitates compilation
(\S\ref{s:absmachine}) to the backend.
\begin{figure}
\begin{tiny}
\begin{lstlisting}
pkt.id1 = hash2(pkt.sport, pkt.dport) \% 8000;
pkt.last_time0 = last_time[pkt.id1];
pkt.last_time0 = pkt.arrival_time;
last_time[pkt.id1] = pkt.last_time0;
\end{lstlisting}
\end{tiny}
\begin{center}
is transformed into
\end{center}
\begin{tiny}
\begin{lstlisting}
pkt.id10 = hash2(pkt.sport, pkt.dport) \% 8000;
pkt.last_time00 = last_time[pkt.id10];
pkt.last_time01 = pkt.arrival_time;
last_time[pkt.id10] = pkt.last_time01;
\end{lstlisting}
\end{tiny}
\caption{SSA transformation}
\label{fig:stateful_flanks}
\end{figure}

%TODO: Maybe once we have enough examples of optimizations, we can roll those
%into SSA as saying how SSA makes it trivial to apply those optimizations.
% Again, this is compiler 101 for anyone who knows it.
