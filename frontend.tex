\section{The \pktlanguage compiler frontend}

We now describe the \pktlanguage compiler frontend. The compiler frontend
operates only on sequential code blocks, allowing us to borrow well-established
techniques from the compiler literature~\cite{muchnik}. However, as we show
throughout this section, constraining \pktlanguage allows us to considerably
simplify the compiler relative to mainstream compilers.

\subsection{Lexical, syntactic, and semantic analysis}
\pktlanguage's syntax is a subset of C, implying that all \pktlanguage are
well-formed C programs that can be compiled by a C compiler like
clang~\cite{clang}. We use clang's library interface~\cite{libclang} to
generate an Abstract Syntax Tree (AST) for a packet transaction written in
\pktlanguage. The remaining compiler passes all operate on an AST produced by
clang.

Embedding \pktlanguage within C has several benefits. It allows to reuse
clang's industrial strength frontend and catches several compiler errors with
no additional effort.  It also allows us to use C's macro preprocessor for
constants. Finally, opaque functions representing hardware primitives (e.g.
hashes and checksum), can be implemented using arbitrary C code and linked with
\pktlanguage code before running the resulting binary on our abstract machine.

\subsection{Converting to straight-line code}
A packet transaction's body can contain convoluted control flow using if-else
statements. Control flow complicates dependence analysis. We eliminate control
flow by transforming if-else statements using the C conditional operator,
starting from the innermost if statements and recursing outwards
(Figure~\ref{fig:if_convert}). This is similar to if
conversion~\cite{allen_if_conversion}, but is much simpler because only the if
and else constructs alter control flow in \pktlanguage and all other forms of
control transfers (break, continue, loops) are forbidden.

We illustrate this on a code fragment from Figure~\ref{fig:flowlet} below:
\begin{figure}
\begin{tiny}
\begin{lstlisting}
if (pkt.arrival_time - last_time[pkt.id1] > FLOWLET_THRESHOLD) {
  saved_hop[pkt.id0] = pkt.new_hop;
}
\end{lstlisting}
\end{tiny}
\begin{center}
is transformed into
\end{center}
\begin{tiny}
\begin{lstlisting}
pkt.tmp0 = pkt.arrival_time - last_time[pkt.id1] > FLOWLET_THRESHOLD;
saved_hop[pkt.id0] = pkt.tmp0 ? pkt.new_hop : saved_hop[pkt.id0];
\end{lstlisting}
\end{tiny}
\caption{Conversion to straight-line code}
\label{fig:if_convert}
\end{figure}

This transformation creates straight-line code, where control always passes
from one statement to the next without any branching. Straight-line code
considerably simplifies the rest of the compiler.

\subsection{Identifying state variables}

We next identify all state variables used in a packet transaction, both arrays
and scalars. State variables represent persistent state stored on the switch
that modifies the behavior of the packet transaction from one step to the next.
In Figure~\ref{fig:flowlet}, \texttt{last\_time} and \texttt{saved\_hop} are
both array-based state variables.

%%We handle state variables differently from packet variables for two reasons.
%%All operations on a particular state variable must happen within one
%%\absmachine atom. This reflects the reality that sharing state variables across
%%atoms or stages is technically challenging because it would require
%%multi-ported memories. Further, all state updates on a state variable should be
%%completed before the next packet is processed. Otherwise, the next packet could
%%see stale values, which would violate the transactional specification.

To identify state variables, we scan the straight-line AST produced by the
previous pass, looking for scalar variables or arrays. For each state variable,
we create a \textit{read flank} to read the state variable into a packet
temporary (if it's an array, we move the indexing expression into the prologue
as well), replace all occurences of the state variable with the packet
temporary, and create a \textit{write flank} that writes the packet temporary into the
state variable.  Figure ~\ref{fig:stateful_flanks} shows this transformation on
the function body of the flowlet switching example.

\begin{figure}
\begin{tiny}
\begin{lstlisting}
pkt.new_hop = hash3(pkt.sport, pkt.dport, pkt.arrival_time \% 64;
pkt.id1 = hash2(pkt.sport, pkt.dport) \% 8000;
pkt.id0 = hash2(pkt.sport, pkt.dport) \% 8000;
pkt.tmp0 = pkt.arrival_time - last_time[pkt.id1] > 5;
saved_hop[pkt.id0] = pkt.tmp0 ? pkt.new_hop : saved_hop[pkt.id0];
last_time[pkt.id1] = pkt.arrival_time;
pkt.next_hop = saved_hop[pkt.id0];
\end{lstlisting}
\end{tiny}
\begin{center}
is transformed into
\end{center}
\begin{tiny}
\begin{lstlisting}
// Read prologue for saved_hop and last_time
pkt.id0 = hash2(pkt.sport, pkt.dport) \% 8000;
pkt.saved_hop0 = saved_hop[pkt.id0];
pkt.id1 = hash2(pkt.sport, pkt.dport) \% 8000;
pkt.last_time0 = last_time[pkt.id1];

pkt.new_hop = hash3(pkt.sport, pkt.dport, pkt.arrival_time) \% 64;
pkt.tmp0 = pkt.arrival_time - pkt.last_time0 > 5;
pkt.saved_hop0 = pkt.tmp0 ? pkt.new_hop : pkt.saved_hop0;
pkt.last_time0 = pkt.arrival_time;
pkt.next_hop = pkt.saved_hop0;

// Write epilogue for saved_hop and last_time
saved_hop[pkt.id0] = pkt.saved_hop0;
last_time[pkt.id1] = pkt.last_time0;
\end{lstlisting}
\end{tiny}
\caption{Adding read and write flanks for state variables}
\label{fig:stateful_flanks}
\end{figure}

At the end of this pass, the code resembles assembly code for a load-store
architecture: state variables are only accessed through reads and writes, and
all arithemtic operations happens on packet variables. Restricting the set of
operations on state variables allows us to simplify reasoning about state
variables when we compile \pktlanguage to the abstract machine
(\S\ref{s:machine}).

% TODO: Mention how resticting accesses to arrays using read/write addresses
% allows us to simplify the stateful pass.

% Any reason, we should be running SSA after stateful_flanks and not the
% other way around? Run it and see.
