\section{A Language for data-plane algorithms}
\label{s:language}

As previously described, data-plane algorithms are characterized by an
irregular control flow and extensive use of stateful processing. Based on these
observations, this section proposes a language to express these algorithms.

To motivate a language for these algorithms, we first observe that any
data-plane algorithm can be expressed as a function that takes in a single
packet and a set of persistent state variables as input. This function then
runs to completion without interruption, modifying the packet and the
persistent state variables in the process. Further, conceptually, only one
packet is processed by this function at any given instant.

This view of data-plane algorithms suggests a natural way to structure them: as
transactions where a function specifies all the required state manipulation and
control flow required for packet processing. The use of transactions is
widespread in packet processing for software-router platforms. For instance,
Click's Element abstraction~\cite{kohler_thesis} specifies packet processing as
a method invocation that isn't pre-empted.  The Linux qdisc
subsystem~\cite{qdisc} exposes an enqueue and dequeue method that specific
algorithms can implement. Intel's IXP architecture for NPUs uses a construct
resembling transactions called a Packet-Processing Stage
(PPS)~\cite{intel_pldi} to express packet processing code.
% https://github.com/torvalds/linux/blob/master/net/sched/sch_codel.c#L256

Relative to these prior systems, our contribution is in observing that
transactions can be profitably used to express data-plane algorithms for
high-speed line-rate switches as well. Realizing this practically requires us
to design a language that expresses packet processing within the body of the
transaction. A good language would strike the right balance between ease of
expression and ease of implementation. Programmable hardware switches
---although a significant advance over their fixed-function counterparts---are
still very restricted in the processing that they do on every packet. This
restriction is required to remain competitive with fixed-function switches.

Based on these observations, we describe our language for packet processing
(Figure~\ref{fig:language}). Our language is a heavily constrained subset of C
that removes all iterative constructs (while, do-while, for, break, continue),
arrays, heaps, and memory allocation. State variables are represented as global
variables. We permit structures to represent packet processing alone, and immediately
desugar these to scalar variables (\S\ref{s:compiler}).

Forbidding loops and other sources of variable performance like memory
allocation, and array scans allows the user to only express code whose
execution latency can be bounded at compile time.  While this may seem overly
restrictive, this is required for the underlying architecture
(\S\ref{s:architecture}), which has deterministic performance regardless of the
traffic pattern or program being run. This results in a different set of
tradeoffs than what programmers are typically used to: a larger program does
not take longer to run. Instead, it may not run at all or might need to be
approximated until it can run (\S\ref{ss:approximation}).

We considered using the recently proposed P4 language~\cite{p4, dc_p4}, which
expresses packet processing as a sequence of match-action tables. P4's match key
is an arbitrary combination of header fields, while the action is built out of
smaller action primitives such as read/write/arithmetic on packet fields.
Together, they represent packet processing carried out in response to a match.

P4, as it currently stands, is too close to the hardware and insufficiently
expressive for our needs. It specifies control flow only across tables, not
within the action in a particular table. Further, it assumes parallel semantics
for action primitives within an action, while most packet-processing code is
written assuming sequential semantics. Lastly, P4 doesn't allow a single action
to manipulate multiple stateful variables all at once. Our work can be viewed
as a recommendation to extend P4 with transactional actions, and can benefit
from the rest of P4's abstractions: arbitrary match entries, typed header
fields, control flow across tables, and programmable packet parsing.
