\section{Evaluation}
\label{s:evaluation}
% Run some experiments with a stateless program.
% 1. We can compile more than one program (CRC16 checker).
% 2. We can compile more than one interesting program.
% 3. That the compilations actually works.
% 4. (Approximations can be omitted for now, punt to future work). 

We built a simple tick-based simulator to evaluate the correctness of
partitioning. Our simulator instantiates a configurable number of pipeline
stages and runs arbitrary code within each stage. To run the
original input transactional code, we create exactly one pipeline stage and run
the entire transactional code within it. \ac{I thought doing this would return 
incorrect results for flowlet.} To run our partitioned code, we create
as many pipeline stages as the number of partitions and run the code from each
partition within the corresponding pipeline stage. \ac{why do you need to do 
that if the compiler already generates partitioned P4 code as output?}

To simulate a variety of random packet inputs to our simulator, we use a
traffic source that samples from a Poisson distribution every clock tick.
While Poisson traffic is unrealistic, it provides sufficient randomness in
time-sensitive packet fields such as the enqueue and dequeue queue sizes,
queueing latencies, and interarrival times. In effect, this creates a set of
random test vectors that we can use to check if the partitioned code is correct
wrt the transactional specification.

\subsection{Correctness}
\label{ss:correctness}

The goal of this experiment is to check that our compiled \pktlanguage program
behaves the same as the original. 
We used Poisson traffic with an intensity of 0.3 and 0.7 packets per tick to
and generated 100000 packets to compare the transactional specification and
pipelined implementation of the flowlet switching. We also randomize the source
and destination ports used to determine the next hop in flowlet switching.

To check for correctness, we print out every packet at the end of all pipeline
stages (at the end of the single pipeline stage for the transactional
specification) and check if they are identical on every field. We used this
method to determine that the flowlet switching example is correctly
partitioned, with very high probability.
% TODO: Mention somewhere how this doesn't change anything. We could use a more
% involved computation like a Jenkins hash, it would just be more painful to show
% in the compiler.
% TODO: Be consistent between pipelined and partitioned.

\subsection{Approximating algorithms}
Present EWMA example. Show how
1. Without MAC instructions, you need to use recirculation, which leverages the approximate nature of EWMA.
2. With MAC instructions, you can do EWMA exactly.
