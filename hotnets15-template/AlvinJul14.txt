1. Explaining our crazy dependency-based algorithm.
2. Alvin's viewpoint: we compile to P4 with extensions,
   we don't say "automatically" compiled.
3. We take advantage of P4's optimizations and so on.

--> Go with the story: Compile Domino to P4.
--> Don't call it: data-plane algorithms at line rate.
--> Instead call it Data-plane programming for everyone.

Compilation to P4 is not totally trivial.
===============================================
Section 2: Hardware / Architecture.
Try and shrink it into one column max:
Basically Section 2 is an extension of the SIGCOMM paper.
2.4 and 2.5 are most important as SIGCOMM paper didn't describe.
Condense 2.1, 2.2, and 2.3 into one paragraph maybe with one paragraph.

If P4 doesn't support tupled instructions, then even if the compiler
can recognize it we are out of luck.

Can we just say we compile to P4 and omit the target architecture altogether? 

Alvin's suggestions: remove stateful instructions:

4. Packed operations on pairs of stateful variables:
y) = (x + y, x - y);
(x,
5. Multiply and accumulate a stateful variable: x = x *
pkt.field + pkt.field2;

if we can't support it AND P4 doesn't support it.

Shrink Section 2 to:
--------------------------
This is the same as the RMT paper from SIGCOMM, and we are explaining the
essential features alone, and maybe also point to the appropriate P4 language
construct.

Keep 2.5 alone. 

-----------------------------
Conclude with a summary at section 2.5 on why building a compiler is difficult:
It's because we need to map a high-level language into a lower-level language / hardware.

=================
Move this to the end or future work:
-------------------------------------

Scheduling, by definition, requires looking at multiple packets together to
make a decision on what packet to schedule next, while data-plane algorithms
operate independenly on each packe

Maybe be a little less negative about this. Just say it can be done later.

Section 3:
------------------
Now reads like related work.
We need to limit the scope of what we are trying to express. 

Maybe make it clear that we are not doing things like prefix match. The goal
of the language is to express things in a easy high-level language.

Don't say stuff like:
===========================================
Traditional examples include forwarding algorithms based
on longest prefix matching and TCAM-based matching. These
examples are characterized by a regular structure that ap-
plies an identical stateless operation on every packet, making
them amenable to high-speed hardware implementations [?].
The success of the OpenFlow interface is in part due to the
widespread availability of these forwarding abstractions (longest-
prefix and ternary match) across most switches today.

It's not required to tell people they can't do X.

Talk about only what you can, not what you can't or don't.

Merge 2 and 3 into something much shorter.
-----------------------------------------

Intro to 4 will depend on the merged 2 + 3.
------------------------------------------
Alvin will add stuff about the grammar.
Paragraph about P4 at the end of 4, should probably go into the intro, so that
it's clear why P4 doesn't work.

Explain the technical challenge in going from domino to P4 in the beginning of
5 or end of 4.

4: Explain motivation for language, what the language is, and introduce the running example.
Here's a running example in our language. Imagine writing P4 code for this. It's so much better.

Change the story in Section 5 to say we are compiling to P4:

Talk about how domino to P4 looks nice but we need to solve it.
Here are the challenges:
1. Partitioning: Figuring out what can be executed in parallel.
2. Stateful business.
3. Handling control flow.
4. A number of preprocessing steps to make the job of partitioner easier.

One-packet compiler is too Russian doll like: compiler within a compiler.

Change the title of 5.4 to something other than the One-Packet Compiler.
Change title to Partitioning based on dependencies or partitioning into tables or something.

Say something more about coalescing:
-----------------------------------------
Ok, so replace 5.4 with a work-list algorithm.

What is missing is a proof of correctness:
---------------------------------------

Work-list algorithm from Alvin:
----------------------------------
1. Totally respect control flow.
2. Every single statement as its own stage.
3. Then, try and combine consecutive stages only if they don't write to the same variable and if one doesn't read a variable written by the other.

===========================================
Alvin's algorithm:
--> Reordering of state variables to bring them as close as possible to avoid recirculation (future pointer)
--> FOllow that with a work list

Double check with Chang on the semantics of read and write in the same clock.
