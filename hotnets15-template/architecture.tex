\section{Primer on programmable switch architectures}
\label{s:architecture}

%\begin{figure*}[t]
%\includegraphics[width=\textwidth]{p4_switch_model.pdf}
%\caption{The protocol-independent switch architecture implemented in the
%abstract machine banzai.}
%\label{fig:architecture}
%\end{figure*}

This way, a state variable $x$ can be read in an atom $A$ in stage 1, written
downstream in stage 2, and then a cloned packet to stage 1 could update the
state variable $x$ in $A$.  However, recirculation has a cost: recirculated
packets consume pipeline capacity by taking away capacity from new data
packets. Further, recirculation latency can be large: several hundred packets
might pass through the pipeline before the recirculated packet updates state in
$A$.

{\textbf Restrictions on atom bodies}
For any high-performance switch that is to operate at an aggregate forwarding
capacity exceeding a Terabit / sec, we need to restrict the complexity of each
statement within the atom and the number of statements within each atom.

To restrict the complexity of each statement, we assume each statement can
carry out simple stateless arithmetic operations (add/sub/shift) on packet
fields. Further, many atoms can execute in parallel using a Very Large
Instruction Word that carries out operations on distinct header fields in
parallel.

To restrict the length of each atom, we note that each atom needs to be
implemented in hardware using an underlying combinational circuit. We describe
(\S\ref{s:mapper}) a mapping procedure that converts sequential code blocks to
configurations of combinational circuits, rejecting atoms that cannot be mapped
to the combinational circuit. We next describe the combinational circuit that
we use for the rest of the paper.

{\textbf The combinational circuit implementing atoms}
At a high level, the combinational circuit represents the limit on useful
packet and state modifications between two packets arriving back-to-back on a
high-performance switch pipeline. These switch pipelines operate at close to 1
Ghz ~\cite{rmt}, implying that the effective budget for packet and state
modifications is about 1 ns.

Keeping this time budget in mind, we assume that the circuit can read, modify,
and write at most two addresses in stateful memory, where the modification to
each address might depend on the previous value in the other address and from
values in at most two packet fields. To restrict the complexity of
modifications, we restrict each stateful modification to a predicated
instruction that can conditionally modify each address based on the value of
the same or another address.

For concreteness, we describe the combinational circuit as an imperative
program below. We use the following notation:
\begin{enumerate}
\item \texttt{state\_hi} and \texttt{state\_lo} refer to two stateful variables
  located at two distinct addresses in stateful memory that are fetched before
  the circuit executes.
\item \texttt{packet\_hi} and \texttt{packet\_lo} refer to two packet fields.
\item \texttt{\{a,b,c\}} denotes the fact that either a, b, or c could be used
in a particular location.
\item \texttt{math} denotes a pure mathematical function approximated as a lookup
  table.
\end{enumerate}

\begin{tiny}
\begin{verbatim}
// Predicates for updates to state
bool condition_a = {+,-} {state_hi, state_lo} {+,-} {packet_hi, packet_lo} + constant {<=, <, ==, !=, >, >=} 0;
bool condition_b = {+,-} {state_hi, state_lo} {+,-} {packet_hi, packet_lo} + constant {<=, <, ==, !=, >, >=} 0;

// Compute one-hot mask from predicates
bool[4] one_hot_mask = compute_one_hot_mask_from condition_a_and_condition_b(condition_a, condition_b);
bool state_hi_alu1_ran = false;

// Execute state_hi's ALUs based on the predicate
int state_hi_alu1_result = 0;
if (state_hi_alu1_mask & one_hot_mask) {
  state_hi_alu1_result = {state_hi, state_lo, constant, math{state_hi, state_lo}} {+, -, min, max} {packet_hi, packet_lo, constant};
  state_hi_alu1_ran = true;
}

int state_hi_alu2_result = 0;
if (state_hi_alu2_mask & one_hot_mask) {
  state_hi_alu1_result = {state_hi, state_lo, constant, math{state_hi, state_lo}} {+, -, min, max} {packet_hi, packet_lo, constant};
  state_hi_alu1_ran = true;
}

// Combine results from both ALUs
if (!state_hi_alu1_ran && !state_hi_alu2_ran) {
  state_hi_alu_result = state_hi;
} else {
  state_hi_alu_result = state_hi_alu1_result | state_hi_alu2_result;
}

// Execute state_lo's ALUs based on the predicate
int state_lo_alu1_result;
if (state_lo_alu1_mask & one_hot_mask) {
  state_lo_alu1_result = {state_hi, state_lo, constant, math{state_hi, state_lo}} {+, -, min, max} {packet_hi, packet_lo, constant};
  state_lo_alu1_ran = true;
}

int state_lo_alu2_result;
if (state_lo_alu2_mask & one_hot_mask) {
  state_lo_alu1_result = {state_hi, state_lo, constant, math{state_hi, state_lo}} {+, -, min, max} {packet_hi, packet_lo, constant};
  state_lo_alu1_ran = true;
}

// Combine results from both ALUs
if (!state_lo_alu1_ran && !state_lo_alu2_ran) {
  state_lo_alu_result = state_lo;
} else {
  state_lo_alu_result = state_lo_alu1_result | state_lo_alu2_result;
}


// Write back results to state_lo and state_hi
state_hi = state_hi_alu_result;
state_lo = state_lo_alu_result;

\end{verbatim}
\end{tiny}
