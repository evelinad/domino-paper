\section{Introduction}
\label{s:intro}

Data-plane algorithms~\cite{cestan} are algorithms that are implemented within
a network switch. These algorithms process every data packet that passes
through the switch, transforming the packet and/or state of the switch itself.
Examples of such algorithms including networking staples such as prefix
lookup~\cite{lookup} and deep packet inspection~\cite{bro_ids}, algorithms for
in-network load balancing~\cite{conga, ecmp}, congestion-control that uses
feedback from switches~\cite{xcp, rcp, pdq, dctcp}, and network
measurement~\cite{minsketch, heavy_hitters}.

Because data-plane algorithms process every packet going through the switch, a
major performance requirement for data-plane algorithms is the ability to run
at the switch's line rate. As a result, these algorithms are primarily
implemented using dedicated hardware. Hardware designs are rigid and
inflexible, making it difficult for network operators and researchers to
experiment with new algorithms.

As such, programmable switch architectures~\cite{flexpipe, xpliant, rmt} allow
designers to express their algorithms using a domain-specific language (DSL)
(e.g., P4~\cite{p4} and Protocol-Oblivious Forwarding~\cite{pof}) and present
a compelling alternative.  Unfortunately, these DSLs are too close to the
underlying network hardware.

P4 is at the forefront of these languages and allows a programmer to specify
packet processing by specifying arbitrary match-action processing in a set of
match-action tables. As it currently stands, P4 is too close to the hardware
and insufficiently expressive for our needs. P4 mixes sequential semantics
across match-action tables with parallel semantics within the actions in a
match-action tables. This is unnatural for programmers that are used to either
a fully sequential model (such as C) or a fully parallel model (such as an SQL
query that conceptually processes all rows).

Besides, a large body of packet-processing code is already written in a
high-level language like C for platforms such as software routers~\cite{click},
the Linux qdisc subsystem~\cite{qdisc} and Network Processors~\cite{npu}. It
would be desirable to leverage this existing corpus of packet-processing
algorithms without having to reimplement all of it in P4.

In this paper, we propose a new DSL, \pktlanguage~(\S\ref{s:language}), for
expressing data-plane algorithms. \pktlanguage is a high-level, imperative
language that allows designers to express data-plane algorithms as
transactions~\cite{transactions}, i.e., blocks of code that conceptually run to
completion on a packet and in isolation from other such blocks of code. Using
transactions allow designers to easily express a wide variety of algorithms, as
has been previously demonstrated in packet-processing code for other network
elements such as software routers and NPUs~\cite{click, intel, qdisc}.
% Anirudh: Transactions in DB provide ACID. I don't think Consistency and
% Durability are totally relevant. Isolation is the property I am going for,
% and atomicity (all or nothing) is vacuously true I guess because I assume
% every code block needs to complete.  Maybe we need to define this precisely
% without boring people :)?

We are in the process of implementing a compiler for
\pktlanguage~(\S\ref{s:compiler}), which partitions transactional code from the
designer into logical P4 tables that can then be compiled by a P4 compiler to
run on programmable switches.  We present preliminary experiments in
implementing real-world data-plane algorithms using
\pktlanguage~(\S\ref{s:evaluation}) and conclude by outlining several areas of
future work~(\S\ref{s:conclusion}).
