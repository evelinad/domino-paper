\section{Introduction}
\label{s:intro}

Data-plane algorithms~\cite{cestan} are algorithms that are implemented within
a network switch. These algorithms process every data packet that passes
through the switch, transforming the packet and/or state of the switch itself.
Examples of such algorithms include in-network load balancing
algorithms~\cite{conga, ecmp}, congestion-control that uses feedback from
switches~\cite{xcp, rcp, pdq, dctcp}, and network measurement~\cite{opensketch,
bitmap_george, elephant_george}.

Because data-plane algorithms process every packet going through the switch, a
major performance requirement is the ability to run at the switch's line rate.
As a result, these algorithms are primarily implemented using dedicated
hardware. Hardware designs are rigid and inflexible, making it difficult to
experiment with new algorithms.

This rigidity affects multiple stakeholders. Companies that build network
switches~\cite{cisco_nexus, dell_force10, arista_7050} based on
merchant-silicon switching chips, would prefer to express new switch features
in firmware, not new hardware.  Datacenter operators like Google, Facebook,
Microsoft, and Amazon would like to experiment with new switch algorithms
within an unencumbered private network.  Finally, researchers continuously come
up with new switch algorithms~\cite{xcp, codel, d3, detail, pdq}, which so far
can be tested only using software routers or a simulator.

Programmable switching chips~\cite{flexpipe, xpliant, rmt} with performance
comparable with state of the art fixed-function chipsets~\cite{trident,
tomahawk, mellanox} have emerged as an alternative.  They allow designers to
express their algorithms using a domain-specific language (DSL) (e.g.,
P4~\cite{p4}, packetC~\cite{packetc}, PX~\cite{px}).  Unfortunately, such DSLs
are too close to the underlying network hardware.  For instance, P4's design
exposes match-action tables as first class objects and bears a close
resemblance to the underlying programmable hardware~\cite{flexpipe, rmt} to
facilitate compiler-backend optimizations such as table
placement~\cite{lavanya_compiler}.

The proximity to hardware complicates language semantics. P4's
semantics~\cite{p4spec} specify that all actions within a given table are
executed in parallel. However, to activate match-action tables, each table
needs to be included in a control-flow program, which executes sequentially.
Taken together, this mix of sequential and parallel semantics means that the
net effect of even extremely simple P4 programs is hard to state crisply.

For instance, consider simple\_router.p4~\cite{simple_router.p4}: a program
that only implements longest-prefix-match IP routing. Its effect, at first glance,
is a sequence of two statements: to apply an IPv4 longest prefix match, and
then to use the match result  to set the destination MAC address. However,
hidden beneath this sequential facade is the fact that the longest prefix match
actually executes three operations in parallel: decrementing the IP TTL field,
setting the egress port, and the next hop IP address in a switch-internal
header.

Mixing sequential and parallel semantics makes it difficult to structure
programs and reason about correctness. It makes it especially hard for
programmers, who are used to writing sequential packet processing programs in a
high-level language such as C (for instance, in software routers~\cite{click,
intel_multicore}, the Linux qdisc subsystem~\cite{qdisc}, and network
processors~\cite{npu}), to reimplement their algorithms in P4.

In this paper, we propose a new DSL, \pktlanguage~(\S\ref{s:language}), for
expressing data-plane algorithms. \pktlanguage is a high-level, imperative
language that allows programmers to express data-plane algorithms for
programmable switch architectures~(\S\ref{s:architecture}) using the concept of
a {\em transaction}: a block of code that executes atomically on each packet
and in isolation from other packets executing the same code block.

We are currently implementing a compiler for \pktlanguage~(\S\ref{s:compiler})
that targets P4 as the backend. Given input source code written as a
transaction in \pktlanguage, our compiler produces a P4 program as an output,
approximating transactional semantics, if required~(\S\ref{ss:patching}.  This
P4 program can then be run through a P4 compiler that carries out backend
optimizations to permit efficient execution on programmable switches.  We
present preliminary experiments demonstrating the correctness of code generated
by the compiler~(\S\ref{s:evaluation}) and conclude with several areas of
future work~(\S\ref{s:future}).
