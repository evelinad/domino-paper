\section{Introduction}
\label{s:intro}

Data-plane algorithms~\cite{cestan} are algorithms that are implemented within
a network switch. These algorithms process every data packet that passes
through the switch, transforming the packet and/or state of the switch itself.
Examples of such algorithms include in-network load balancing
algorithms~\cite{conga, ecmp}, congestion-control that uses feedback from
switches~\cite{xcp, rcp, pdq, dctcp}, and network measurement~\cite{minsketch,
heavy_hitters}.

Because data-plane algorithms process every packet going through the switch, a
major performance requirement is the ability to run at the switch's line rate.
As a result, these algorithms are primarily implemented using dedicated
hardware. Hardware designs are rigid and inflexible, making it difficult for
network operators and researchers to experiment with new algorithms.

Programmable switch architectures~\cite{flexpipe, xpliant, rmt} with
performance comparable with state-of-the-art fixed-function
chipsets~\cite{tomahawk, mellanox} have emerged as an alternative. They allow
designers to express their algorithms using a domain-specific language (DSL)
(e.g., P4~\cite{p4}).  Unfortunately, such DSLs are designed to be very close
to the underlying network hardware.

For instance, a P4 programmer specifies packet processing by programming the
match and action parts in a set of match-action tables. P4's semantics are such
that all actions included in a given table are executed in
parallel~\cite{p4Spec}. However, to activate match-action tables, each table needs
to be included in a control-flow program, which executes sequentially.

P4's design was chosen for a close correspondence with the underlying
programmable hardware~\cite{flexpipe, rmt} and allows the compiler to carry out
backend optimizations such as table placement~\cite{lavanya_compiler}.
However, mixing sequential and parallel semantics makes it difficult to
structure programs and reason about correctness. This makes it harder for
programmers, who are used to writing sequential packet processing programs in a
high-level language such as C (for instance, in software routers~\cite{click},
the Linux qdisc subsystem~\cite{qdisc}, and network processors~\cite{npu}), to
reimplement their algorithms in P4.

In this paper, we propose a new DSL, \pktlanguage~(\S\ref{s:language}), for
expressing data-plane algorithms. \pktlanguage is a high-level, imperative
language that allows programmers to express data-plane algorithms using the
concept of a {\em transaction}: a block of code that executes atomically on
each packet and in isolation from other packets executing the same code block.
%\ac{does the citation defines what transactions are in networking? If so we
%should just quote from that} Anirudh: Not sure if this covers it? Let me know
%what you think.

%
%Using transactions allow designers to easily express a wide variety of
%algorithms, as has been previously demonstrated in packet-processing code for
%other network elements such as software routers~\cite{click},
%NPUs~\cite{intel}, active queue-management and scheduling
%algorithms~\cite{qdisc}, and SDN controllers~\cite{maple}.
%Anirudh: We repeat this in too many places including language.tex and two paragraphs
%above.

We are currently implementing a compiler for \pktlanguage~(\S\ref{s:compiler})
that targets P4 as the backend. Given input source code written as a
transaction in \pktlanguage, our compiler produces a P4 program as an output.
This P4 program can then be run through a P4 compiler that carries out backend
optimizations to permit efficient execution on programmable switches.  We
present preliminary experiments in expressing non-trivial real-world data-plane
algorithms using \pktlanguage~(\S\ref{s:evaluation}) and conclude with several
areas of future work~(\S\ref{s:conclusion}).
