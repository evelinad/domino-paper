\section{Programming using packet transactions}
%TODO: Mihai's comments about how we can add return and switch
% statements to the language. Don't undersell!
\label{s:transactions}

\begin{table}
  \begin{tabular}{p{0.9\columnwidth}}
    No iteration (while, for, do-while).\\
    No switch, goto, return, break, or continue.\\
    No pointers.\\
    No dynamic memory allocation / heap.\\
    Array index must be constant over the duration of a packet. \ac{what does
    duration a packet mean?}\\
    No access to packet data.\\
  \end{tabular}
  \caption{Restrictions in \pktlanguage}
  \label{tab:restrict}
\end{table}
\begin{figure*}[!t]
\begin{minipage}{0.6\textwidth}
\begin{small}
\begin{lstlisting}[style=customc]
#define NUM_FLOWLETS    8000
#define THRESHOLD       5
#define NUM_HOPS        10

struct Packet {
  int sport;
  int dport;
  int new_hop;
  int arrival;
  int next_hop;
  int id; // array index
};

int last_time [NUM_FLOWLETS] = {0};
int saved_hop [NUM_FLOWLETS] = {0};

void flowlet(struct Packet pkt) {
  pkt.new_hop = hash3(pkt.sport,
                      pkt.dport,
                      pkt.arrival)
                % NUM_HOPS;

  pkt.id  = hash2(pkt.sport,
                  pkt.dport)
            % NUM_FLOWLETS;

  if (pkt.arrival - last_time[pkt.id]
      > THRESHOLD)
  { saved_hop[pkt.id] = pkt.new_hop; }

  last_time[pkt.id] = pkt.arrival;
  pkt.next_hop = saved_hop[pkt.id];
}
\end{lstlisting}
\end{small}
\end{minipage}
%
\vrule\quad
%
\begin{minipage}{0.4\textwidth}
\includegraphics[width=0.8\columnwidth]{pipe.pdf}
\end{minipage}
\caption{\small (a) Flowlet switching written in \pktlanguage (left);
(b) Compiled 6-stage pipeline in \absmachine implementing (a).  Control flows
from top to bottom. Atoms manipulating state are shaded in blue (right).}
\label{fig:flowlet}
\end{figure*}

We now illustrate programming using packet transactions in \pktlanguage, using
flowlet switching~\cite{flowlets} as an example. Flowlet switching is a
load-balancing algorithm that sends bursts of packets (called flowlets) from a
TCP flow on different paths, provided the bursts are separated by a large
enough interval in time to ensure packets do not arrive out of order at the TCP
receiver. Figure~\ref{fig:flowlet} shows how flowlet switching is expressed in
\pktlanguage. For simplicity, the example hashes only the source and
destination ports; it is easy to extend this to the full 5-tuple.

This example demonstrates the core language constructs in \pktlanguage. All
packet processing happens in the context of a packet transaction (the function
\texttt{flowlet} starting on line 17). %, a C function taking a C struct as an argument.
The parameter {\tt pkt} declares the fields in a packet (lines 5--12)\footnote{We use fields
to refer to both packet headers such as source port ({\tt sport}) and destination
port ({\tt dport}) and packet metadata ({\tt id}).} that can be referenced by the function
body (lines 18--32).  In addition, the function body can reference state
variables that represent persistent state stored on the switch. These are
declared as global variables (e.g. \texttt{last\_time} and \texttt{saved\_hop}
declared on lines 14 and 15, respectively).

Conceptually, the switch invokes 
the packet transaction function on each incoming packet sequentially.
% modifies the passed-in packet argument
%until the end of the function body, before processing the next packet.
%\pktlanguage forbids return statements implying that execution will always end
%at the end of the function body. 
The language does not include statements that alter control flow, hence each
packet transaction function is executed in its entirety.
The function may invoke
\textit{intrinsics} such as \texttt{hash2} on lines 23 and \texttt{hash3} on
line 18 in the example.  Intrinsics are hardware primitives provided by the abstract machine
that are not interpreted by \pktlanguage. The \pktlanguage compiler uses an
intrinsic's signature to infer dependencies and supplies a canned run-time
implementation, but otherwise does not interpret or analyze intrinsics. The
overall language is essentially a constrained subset of C
(Table~\ref{tab:restrict}).
% Anirudh->Alvin: Yes. No one will get BNF :)
%\ac{This essentially is an imprecise version of the 
%  grammar. Maybe this is more understandable to networking audience?

As an illustration of the restrictions, 
arrays can be used as state variables alone but not as packet fields.
Furthermore, all accesses to a given array inside a transaction are restricted
to the same index.
%while a packet transaction's body is being executed for a
%specific packet, all accesses to an array variable must use the same index. 
%For subsequent packets, this index can be different. 
For instance, all accesses to
the array \texttt{last\_time} use the index \texttt{pkt.id}, which is constant
for each packet, but changes from one packet to the next. This restriction
simplifies the treatment of arrays in the compiler, while still allowing us to
express several data-plane algorithms of practical interest. \ac{how is this enforced?}

These restrictions seem overly severe, but are required to provide
deterministic performance guarantees. Memory allocation, unbounded iteration
counts, and unstructured control flow cause unpredictable run-time
performance. These are also precisely the restrictions in \pktlanguage relative
to languages like Click~\cite{click} that target general-purpose software
routers with greater flexibility and more variable performance.

When compiled to a \absmachine machine (\S\ref{s:absmachine}), the \pktlanguage
compiler converts the code in Figure~\ref{fig:flowlet}a into the pipelined form
shown in Figure~\ref{fig:flowlet}b. Today, programmable switch chips are
programmed by manually specifying low-level configurations resembling
Figure~\ref{fig:flowlet}b using a language like P4. \pktlanguage's compiler
automates this process. \ac{I don't get this. Isn't translating from domino to 
pisa to same as translating P4 to hardware primitives?}
