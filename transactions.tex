%TODO: Talk about how transactions can be composed.
% We 'll need to do this for the PIFO work as well.

\section{Packet transactions}
\label{s:transactions}

\begin{figure*}[!t]
\begin{minipage}{0.5\textwidth}
\begin{small}
\begin{lstlisting}[style=customc]
#define NUM_FLOWLETS    8000
#define THRESHOLD       5
#define NUM_HOPS        10

struct Packet {
  int sport;
  int dport;
  int new_hop;
  int arrival;
  int next_hop;
  int id; // array index
};

int last_time [NUM_FLOWLETS] = {0};
int saved_hop [NUM_FLOWLETS] = {0};

void flowlet(struct Packet pkt) {
  pkt.new_hop = hash3(pkt.sport,
                      pkt.dport,
                      pkt.arrival)
                % NUM_HOPS;

  pkt.id  = hash2(pkt.sport,
                  pkt.dport)
            % NUM_FLOWLETS;

  if (pkt.arrival - last_time[pkt.id] @\label{line:ifStart}@
      > THRESHOLD)
  { saved_hop[pkt.id] = pkt.new_hop; } @\label{line:ifEnd}@

  last_time[pkt.id] = pkt.arrival;
  pkt.next_hop = saved_hop[pkt.id];
}
\end{lstlisting}
\end{small}
\caption{Flowlet switching written in \pktlanguage}
\label{fig:flowlet_code}
\end{minipage}
%
\vrule\quad
%
\begin{minipage}{0.4\textwidth}
\includegraphics[width=0.8\columnwidth]{pipe.pdf}
\caption{Compiled 6-stage \absmachine pipeline implementing flowlet
switching.  Control flows from top to bottom. Atoms manipulating state are
shaded in blue.}
\label{fig:flowlet_pipeline}
\end{minipage}
\end{figure*}

We now illustrate programming using packet transactions in \pktlanguage, using
flowlet switching~\cite{flowlets} as an example. Flowlet switching is a
load-balancing algorithm that sends bursts of packets (called flowlets) from a
TCP flow on different paths, provided the bursts are separated by a large
enough time interval to ensure packets do not arrive out of order at a TCP
receiver. Figure~\ref{fig:flowlet_code} shows flowlet switching in
\pktlanguage. For simplicity, we hash only the source and destination ports; it
is easy to extend it to the full 5-tuple.

This example demonstrates the core language constructs in \pktlanguage. All
packet processing happens in the context of a packet transaction (the function
\texttt{flowlet} starting at line 17). The function's argument {\tt pkt}
declares the fields in a packet (lines 5--12)\footnote{We use fields to refer
to both packet headers such as source port ({\tt sport}) and destination port
({\tt dport}) and packet metadata ({\tt id}).} that can be referenced by the
function body (lines 18--32).  The function body can also modify persistent
switch state using global variables (e.g.  \texttt{last\_time} and
\texttt{saved\_hop} on lines 14 and 15, respectively).

Conceptually, the switch invokes the packet transaction function on each
incoming packet sequentially. To the programmer, the function modifies the
passed-in packet argument and runs to completion before processing the next
packet.  The function may invoke \textit{intrinsics} such as \texttt{hash2} on
line 23 to use hardware accelerators such as hash generators.  The \pktlanguage
compiler uses an intrinsic's signature to infer dependencies and supplies a
canned run-time implementation, but otherwise does not analyze an intrinsics's
internal behavior.

\subsection{Constraints on the language}
%%\pktlanguage relative to software
%%routers like Click~\cite{click} with greater flexibility and variable
%%performance.

The overall language is a constrained subset of C
(Table~\ref{tab:restrict}).  These constraints are required for
deterministic performance.  Memory allocation, unbounded iteration
counts, and unstructured control flow all cause variable performance,
which may prevent an algorithm from achieving line rate.
Furthermore, all accesses to a given array within one execution of a
transaction, i.e. one packet, must use the same array index. For
example, all read and write accesses to the array \texttt{last\_time}
use the index \texttt{pkt.id}, which is constant for each packet, but
can change between packets. This restriction mirrors restrictions on
memories, where supporting distinct read and write addresses every
clock cycle is challenging.\MA{Do we model this restriction in PISA?
  It would be better to add it to Sec 2.}

\begin{table}
  \begin{tabular}{p{0.9\columnwidth}}
    No iteration (while, for, do-while).\\
    No goto, break, or continue.\\
    No pointers.\\
    No dynamic memory allocation / heap.\\
    Array index is constant for each transaction execution.\\
    No access to data i.e. unparsed portion of the packet.\\
    No arrays in packet fields.\\
  \end{tabular}
  \caption{Restrictions in \pktlanguage}
  \label{tab:restrict}
\end{table}

\subsection{All-or-nothing compilation}

When compiled to a \absmachine machine (\S\ref{s:absmachine}), the
\pktlanguage compiler (\S\ref{s:compiler}) converts the code in
Figure~\ref{fig:flowlet_code} into the atom pipeline in
Figure~\ref{fig:flowlet_pipeline}. If it succeeds, the compiler
guarantees that the program will run at line rate on the target.
Otherwise, the compiler rejects the program outright; there is no
smooth tradeoff between a program's performance and its complexity.
This {\em all-or-nothing} compilation model is unusual for someone
programming other computational substrates such as a CPU, GPU, or
DSP. But, it reflects how routers and switches are used today. Routers
are rated for a particular line rate, regardless of the feature set
that an operator enables. 

% This all-or-nothing model provides
% predictable performance for free---in contrast to software-routers
% that need explicit support for it~\cite{dobrescu2012, wenfei15}.
% MA: I would just get rid of this last sentence. It's not really
% "free", you lose some capability.

\subsection{Limitations of packet transactions}

Packet transactions are a good fit for data-plane algorithms that do a
small amount of work per packet (i.e. where the amount of work can be
bounded at compile time) and manipulate only packet
headers. Data-plane algorithms like deep packet inspection and wan
optimization access packet payloads. These algorithms require a switch
to parse the packet payload as well---effectively parsing a huge
header consisting of each byte in the packet payload. Parsing deep
parse graphs is challenging at line rates of 1 GHz.\MA{So this is more
  a limitation of the parser than the transactional model. A better
  example might be an algorithm that manipulates a large amount of
  state, but does not need to run on every packet. For example,
  periodically scanning a list of numbers to find their average might
  be possible in hardware.}  Consequently, the limitations of packet
transactions merely reflect fundamental limitations of the underlying
hardware.
%% TODO: Move the parsing limitation into section 2 as a limitation of the machine itself,
%% not the packet transaction model itself.

%% TODO: Think of things in the middle between packet transactions and
%% the control plane. Trigger packets once in a while to do some clean
%% up operations, every so often. Explain that as a limitation of the
%% packet transaction model.

%% Move both of these things to section 2.
%% Instead of having 2.5, merge resource limits into 2.4 and create a new
%% subsection called limitations of line-rate switches.

%% Call 2.4 "limitations on the PISA model".
%% The focus is on algorithms that run at line rate and process a packet every clock cycle.
%% This poses restrictions.

%% Merge 2.4 and 2.5
%% Make a section that says: "What can PISA not do?" at the end of pisa.tex and add the two
%% limitations from line-rate: parsing and middle-plane computations.
