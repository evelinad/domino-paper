\section{Introduction}
\label{s:intro}

Data-plane algorithms~\cite{cestan} are algorithms that are implemented within
a network switch. These algorithms process every data packet that passes
through the switch, transforming the packet and often also some state stored on
the switch.  Examples of such algorithms include congestion-control that uses
feedback from switches~\cite{xcp, rcp, pdq, dctcp}, active queue
management~\cite{codel}, network measurement~\cite{opensketch, bitmap_george,
elephant_george}, and load-balanced routing in the data plane~\cite{conga}.

Because data-plane algorithms process every packet, an important implementation
requirement is the ability to process packets at line rate.  Consequently,
these algorithms are primarily implemented using dedicated hardware. However,
hardware designs are rigid, making it difficult to experiment with new
algorithms.

This rigidity affects network switch vendors that build network
equipment~\cite{cisco_nexus, dell_force10, arista_7050} based on
merchant-silicon switching chips~\cite{trident, tomahawk, mellanox}, network
operators using such chips within private networks~\cite{google,facebook,vl2},
and researchers developing new switch algorithms~\cite{xcp, codel, d3, detail,
pdq}. Today, the only way to implement a new data-plane algorithm at line rate
is to expressly build hardware for it---a time-consuming and resource-intensive
process.

Programmable switching chips~\cite{flexpipe, xpliant, rmt} that are competitive
with state of the art fixed-function chipsets~\cite{trident, tomahawk,
mellanox} have emerged as an alternative.  These chips allow designers to
express their algorithms using a domain-specific language (DSL) such as
P4~\cite{p4} or proprietary SDKs such as those from XPliant~\cite{xpliant_sdk,
xpliant_sdk2} and Intel~\cite{intel_sdk}.  However, these approaches closely
resemble the underlying hardware and are inconvenient for programmers.

For instance, P4 requires the user to manually specify the sequence of
match-action tables that every packet goes through. Further, instructions
contained within an action in P4 are assumed to execute in parallel to reflect
the hardware's parallel processing capabilities. This forces programmers to
reason about hardware details such as pipelining and parallelism, and places a
high burden on network programmers who are used to writing sequential programs
in a high-level language (such as C) for software routers~\cite{click} and
network processors~\cite{ixp4xx, ixp2800}.

In this paper, we present \pktlanguage, a new DSL for expressing data-plane
algorithms. \pktlanguage is a high-level, imperative language based on C that
allows programmers to express data-plane algorithms using {\em packet
transactions} (\S\ref{s:transactions}). Packet transactions provide the
abstraction of a sequential block of code that runs to completion on each
packet before executing on the next packet. This is a convenient programming
model, since it allows the programmer to focus on the operations needed for
each packet without worrying about other packets concurrently being processed
by the switch pipeline.

We have implemented a compiler for \pktlanguage that compiles \pktlanguage
packet transactions and generates code for a family of abstract machines called
\absmachine~(\S\ref{s:absmachine}). \absmachine generalizes recent work on the
Reconfigurable Match Table~\cite{rmt} model and captures the essential features
of emerging programmable switch architectures~\cite{rmt, xpliant, flexpipe}.

In addition, \absmachine introduces the concept of {\em atoms} to represent
atomic computations provided natively by an instance of \absmachine much like
test-and-set, compare-and-exchange, and packed-multiply-and-add in x86 CPUs
today~\cite{x86_manual}.  Atoms provide the underlying atomic hardware
operations required to implement the programmer's view of packet transactions,
similar to how an atomic test-and-set is used to implement an atomic increment.
%A template of the atoms available in a \absmachine instance is provided to the
%\pktlanguage compiler for code generation.

The \pktlanguage compiler guarantees deterministic performance for packet
transactions: all packet transactions that are implementable on a given switch
architecture will be executed at the switch's line rate, or they will be
rejected by the compiler if the atoms available in a \absmachine instance cannot
implement the programmer-supplied transaction.

To evaluate the usefulness of \pktlanguage, we use \pktlanguage to express
several data-plane algorithms~(\S\ref{s:eval}) such as flowlet
switching~\cite{flowlets}, data-plane bloom filters~\cite{bloom}, heavy-hitter
detection, CoDel~\cite{codel}, and CONGA~\cite{conga}---each algorithm taking
up less than a hundred lines of \pktlanguage code.  The \pktlanguage compiler
determines if each algorithm can run at line rate for several instances of
\absmachine that differ in the atoms they provide~(Table~\ref{table:eval}).
%We
%place \pktlanguage in the context of related work~(\S\ref{s:related}) and
%conclude by outlining several areas for future work~(\S\ref{s:future}).
