\section{Introduction}
\label{s:intro}

Network switches and routers in modern datacenters, enterprises, and
service-provider networks perform many tasks in addition to standard
packet forwarding. The set of requirements for routers has only
increased with time as network operators seek greater control over
performance and security.  Performance and security may be improved
using both data-plane and control-plane mechanisms. This paper focuses
on data-plane algorithms. These algorithms process and transform
packets, creating and maintaining state in the switch. Examples
include active queue management~\cite{red,blue,avq,codel,pie},
scheduling~\cite{pifo_hotnets}, congestion control with switch
feedback~\cite{xcp, rcp, pdq, dctcp}, network
measurement~\cite{opensketch, bitmap_george, elephant_george},
security~\cite{dns_change}, and traffic load balancing~\cite{conga}.

An important requirement for data-plane algorithms is the ability to
process packets at the switch's line rate (typically 10--100 Gbit/s on
10--100 ports).  As a result, these
algorithms are typically implemented using dedicated
hardware. Hardware designs are rigid, however, and not reconfigurable
in the field. Thus, to implement and deploy a new algorithm today, or
to even modify a deployed one, the user must invest in new
hardware---a time-consuming and expensive proposition.

This rigidity affects many stakeholders adversely:
vendors~\cite{cisco_nexus, dell_force10, arista_7050} building network
switches with merchant-silicon chips~\cite{trident, tomahawk,
  mellanox}, network operators deploying
switches~\cite{google,facebook,vl2}, and researchers developing new
switch algorithms~\cite{xcp, codel, d3, detail, pdq}.  

To run data-plane algorithms after a switch has been built,
researchers and companies have attempted to build programmable routers
for many years, starting from efforts on active
networks~\cite{active-nets} to network processors~\cite{npu_survey} to
software routers~\cite{click, dpdk, routebricks}. All these efforts
sacrificed performance for programmability, typically running an order
of magnitude (or worse) slower than hardware line
rates. Unfortunately, this reduction in performance has meant that
these systems are rarely deployed in production networks, if at all.

Programmable switching chips~\cite{flexpipe, xpliant, rmt, corsa,
  uadp, algo_logic} competitive in performance with state-of-the-art
fixed-function chipsets~\cite{trident, tomahawk, mellanox} are now
becoming available. These chips implement a few low-level hardware
primitives that can be configured by software into a processing
pipeline, and are
field-reconfigurable~\cite{xpliant_sdk,xpliant_sdk2,intel_sdk}. Building
a switch with such a chip is attractive because it does not compromise
on data rates~\cite{rmt}.

In terms of programmability, these chips today allow the network
operator to specify packet parsing and forwarding without restricting
the set of protocol formats or the set of actions that can be executed
when matching packet headers in a match-action table. Languages such
as P4 are emerging as a way to express such {\em match-action
  processing} in a hardware-independent way~\cite{p4,p4spec,dc_p4}.

There is a gap between this form of programmability and the needs of data-plane
algorithms. By contrast to packet header parsing and forwarding, which don't
modify state in the data plane, many data-plane algorithms create and modify
algorithmic state in the switch as part of packet processing. For such
algorithms, it is important for programmability to directly capture the
algorithm's intent without requiring it to be ``shoehorned'' into hardware
constructs such as a sequence of match-action tables. Indeed, this is how such
data-plane algorithms are expressed in pseudocode~\cite{red, csfq, codel_code,
avq, blue}, and implemented in software routers~\cite{click, dpdk,
routebricks}, network processors~\cite{packetc, nova}, and network
endpoints~\cite{qdisc}.

By studying the requirements of data-plane algorithms and the
constraints of line-rate hardware, we introduce a new abstraction to
program and implement data-plane algorithms: a {\em packet
  transaction} (\S\ref{s:transactions}). A packet transaction is a
sequential code block that is atomic and isolated from other such code
blocks (i.e., any visible state is equivalent to a serial execution of
packet transactions across packets). Packet transactions allow the programmer to
focus on the operations needed for each packet without worrying about
other concurrent packets.

We have designed and implemented {\em \pktlanguage{}}, a new
domain-specific language (DSL) for data-plane algorithms, with packet
transactions at its core.  \pktlanguage is an imperative language with
C-like syntax, perhaps the first to offer such a high level
programming abstraction for line-rate switches.

This paper makes three further contributions. First, {\em
  \absmachine}, a machine model for line-rate programmable switches
(\S\ref{s:absmachine}). \absmachine generalizes and abstracts
essential features of line-rate programmable switches~\cite{rmt,
  xpliant, flexpipe}. \absmachine also models practical constraints
limiting stateful operations at line rate.  Informed by these
constraints, we introduce the concept of {\em atoms} to represent a
programmable switch's instruction set.

Second, {\em a compiler from \pktlanguage packet transactions to a
  \absmachine target}~(\S\ref{s:compiler}). The \pktlanguage compiler
introduces \textit{all-or-nothing compilation}, where all packet
transactions accepted by the compiler will run at line rate, or be
rejected outright. There is no ``slippery slope'' of running network
algorithms at lower speeds as with traditional network processors or
software routers: when compiled, a \pktlanguage program runs at the
line rate, or not at all. Performance is not just predictable, but
is guaranteed.

Third, {\em an evaluation of \pktlanguage} (\S\ref{s:eval}). We evaluate
\pktlanguage's expressiveness by programming a variety of data-plane
algorithms (Table~\ref{tab:algos}) in \pktlanguage and compare with
P4. We find that \pktlanguage provides a more concise and easier
programming model for stateful data-plane algorithms.  Next, because
no existing programmable switch supports the set of atoms required for
our data-plane algorithms, we design a set of compiler targets
(\S\ref{ss:targets}) based on \absmachine and show that these are
feasible in a 32 nm standard-cell library with $< 15\%$ estimated chip area
overhead.  Finally, we compile data-plane algorithms written in
\pktlanguage to these targets to show how the choice of atoms in a
target determines which algorithms it can support.

%% 1. Lay out the paper like this in the introduction:
%% Packet transactions are our abstraction, all-or-nothing is our approach.
%% 
%% We have three core new ideas:
%% 1. A machine model (what's hard: memory constraints, time budgets for stateful
%% operations)
%% 2. A language with restrictions for line-rate informed by the machine model.
%% 3. A compiler that extracts atomic components aka. codelets.
