\section{Introduction}
\label{s:intro}

Data-plane algorithms~\cite{cestan} are algorithms that are implemented within
a network switch. These algorithms process every data packet that passes
through the switch, transforming the packet and/or state stored on the switch.
Examples of such algorithms include congestion-control that uses feedback from
switches~\cite{xcp, rcp, pdq, dctcp}, active queue management~\cite{codel},
network measurement~\cite{opensketch, bitmap_george, elephant_george}, and
load-balanced routing in the data plane~\cite{conga}.

Because data-plane algorithms process every packet, an important requirement is
the ability to run at the switch's line rate.  As a result, these algorithms
are primarily implemented using dedicated hardware. However, hardware designs
are rigid and inflexible, making it difficult to experiment with new
algorithms.

This rigidity affects network switch vendors that build network
equipment~\cite{cisco_nexus, dell_force10, arista_7050} based on
merchant-silicon switching chips~\cite{trident, tomahawk, mellanox},  network
operators using such chips within private networks~\cite{google,facebook,vl2},
and researchers developing new switch algorithms~\cite{xcp, codel, d3, detail,
pdq}. Today, the only way to implement a new data-plane algorithm at line rate
is to expressly build hardware for it---a time-consuming and resource-intensive
process.

Programmable switching chips~\cite{flexpipe, xpliant, rmt} that are
performance-competitive with state of the art fixed-function
chipsets~\cite{trident, tomahawk, mellanox} have emerged as an alternative.
These chips allow designers to express their algorithms using a domain-specific
language such as P4~\cite{p4} or propreitary SDKs such as the XPliant
SDK~\cite{xpliant_sdk, xpliant_sdk2} and the Intel Ethernet Switch
SDK~\cite{intel_sdk}.

These approaches bear a close resemblance to the underlying hardware, forcing
programmers to reason about low-level pipeline semantics and hardware
concurrency, and place a high burden on network programmers who are used to
writing sequential programs in a high-level language (such as C) for software
routers~\cite{click} and network processors~\cite{ixp4xx, ixp2800}.

This paper presents a new DSL, \pktlanguage, for expressing data-plane
algorithms. \pktlanguage is a high-level, imperative language that allows
programmers to express data-plane algorithms using {\em packet transactions}
(\S\ref{s:transactions}): sequential blocks of code that run to completion on
each packet and in isolation from other packets executing the same code block.
\pktlanguage's design is influenced by the capabilities of switch targets: for
instance, it forbids all iterative constructs. \pktlanguage's constrained
design leads to a simpler compiler for \pktlanguage~(\S\ref{s:compiler}),
relative to compilers~\cite{nova, packetc, microenginec} for imperative
languages that target more flexible devices such as network processors and
software routers.

The \pktlanguage compiler compiles packet transactions written in \pktlanguage
to  code for an abstract machine \absmachine~(\S\ref{s:absmachine})
representing essential elements of programmable switches.  In particular,
\absmachine introduces \textit{atoms}: sequential code blocks consisting of
multiple packet-processing instructions. \absmachine executes these
instructions atomically: their effect is visible in entirety before the next
packet is processed. Internally, an atom can encapsulate local state that
affects the atom's behavior from packet to packet to model elements like switch
counters.

Using atoms as building blocks, \absmachine specifies a switch pipeline as an
atom grid with the horizontal axis representing physical pipeline stages and
the vertical axis representing concurrency within each stage.  By constraining
the number and type of instructions within each atom~(\S\ref{ss:complexity}),
\absmachine captures practical limits on the computation that can be carried
out between packets in line-rate switches.

While existing uses of transactions in databases~\cite{db_trans} guarantee
isolation, transaction throughput depends on transaction complexity. Packet
transactions, by contrast, guarantee constant throughput. All packet
transactions that are implementable can run at the switch's line rate, or are
rejected by the compiler.

Expressing data-plane algorithms as packet transactions also helps in program
verification.  A packet transaction is just one large atom, and hence can be
executed on \absmachine.  By feeding the same test input to both the
user-supplied packet transaction and its pipelined implementation and verifying
that the outputs match up, we can spot check the correctness of
compilations~(\S\ref{s:tester}).

%TODO: Explain one real use case for bloom filters. Everyone talks about it but
%I don't seem to know what the real use case is.
We use \pktlanguage to express several data-plane algorithms~(\S\ref{s:eval})
such as flowlet switching~\cite{flowlets}, data-plane bloom
filters~\cite{bloom}, heavy-hitter detection, CoDel~\cite{codel}, and
CONGA~\cite{conga}. We determine if they are implementable, for specific
constraints~(\S\ref{ss:complexity}) imposed on the atoms in \absmachine. In the
process, we provide guidance for how programmable hardware should evolve in the
future to support the needs of data-plane algorithms.  We place \pktlanguage in
the context of related work~(\S\ref{s:related}) and conclude by outlining several
areas for future work~(\S\ref{s:future}).
%TODO: I don't quite know what the guidance is yet. Will have it by the
%weekend.
