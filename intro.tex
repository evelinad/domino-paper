\section{Introduction}
\label{s:intro}

Network switches and routers in modern datacenters, enterprises, and
service-provider networks perform many tasks in addition to standard
packet forwarding. The set of requirements for routers has only
increased with time as network operators seek greater control over
performance and security.  Performance and security may be improved
using both data-plane and control-plane mechanisms. This paper focuses
on data-plane algorithms. These algorithms process and transform
packets, creating and maintaining state in the switch. Examples
include active queue management~\cite{red,blue,avq,codel,pie},
scheduling~\cite{pifo_hotnets}, congestion control with switch
feedback~\cite{xcp, rcp, pdq, dctcp}, network
measurement~\cite{opensketch, bitmap_george, elephant_george}, and
load-balanced routing in the data plane~\cite{conga}.

An important practical requirement for data-plane algorithms is the
ability to process packets at the switch's line rate.  As a result,
these algorithms are typically implemented using dedicated
hardware. Hardware designs are rigid, however, and not reconfigurable
in the field. Thus, to implement and deploy a new algorithm today, the
user must invest in new hardware---a time-consuming and expensive
proposition.

This rigidity affects many stakeholders adversely:
vendors~\cite{cisco_nexus, dell_force10, arista_7050} building network
switches with merchant-silicon chips~\cite{trident, tomahawk,
  mellanox}, network operators deploying
switches~\cite{google,facebook,vl2}, and researchers developing new
switch algorithms~\cite{xcp, codel, d3, detail, pdq}.  To run
data-plane algorithms after a switch has been built, researchers and
companies have attempted to build programmable routers for many years,
starting from efforts on active networks~\cite{active-nets} to network
processors~\cite{npu_survey} to software
routers~\cite{click,routebricks}. All these efforts have sacrificed
performance for programmability, typically running an order of
magnitude (or worse) slower than hardware line rates. Unfortunately,
this reduction in performance has meant that these systems are rarely
deployed in production networks, if at all.

Programmable switching chips~\cite{flexpipe, xpliant, rmt, corsa,
  uadp, algo_logic} competitive in performance with state-of-the-art
fixed-function chipsets~\cite{trident, tomahawk, mellanox} are now
becoming available. These chips implement a few low-level hardware
primitives that can be configured by software into a processing
pipeline~\cite{xpliant_sdk,xpliant_sdk2,intel_sdk}.  This approach is
attractive because it does not compromise on data rates and adds
modest area overhead for programmability~\cite{rmt}. From an
operational standpoint, these chips permit field reconfigurability, a
feature that other computational substrates like CPUs, GPUs,
DSPs have benefited from for many years now.

These chips allow engineers to to specify packet parsing and
forwarding without restricting the set of protocol formats or the set
of actions that can be executed when matching packet headers in a
match-action table. Languages such as P4 are emerging as a way to
express such match-action processing in a hardware-independent
way~\cite{p4,p4spec,dc_p4}.

%Data-plane tasks that require large
%amounts of header rewriting can be expressed naturally in
%P4~\cite{dc_p4}.

In contrast to packet header parsing and forwarding, which are stateless
and don't programmatically manipulate any state in the data plane, many data-plane algorithms
create and modify algorithmic state in the switch as part of packet
processing. For such algorithms, it is important for programmability to
directly capture the algorithm's intent without requiring it to be
``shoehorned'' into hardware constructs such as a sequence of
match-action tables. Indeed, this is how such algorithms are expressed
in pseudocode~\cite{red, csfq, codel_code, avq, blue}, and implemented
in sofware routers~\cite{click, dpdk, routebricks}, network
processors~\cite{packetc, nova}, and at network
endpoints~\cite{qdisc}.

This paper presents \pktlanguage, a new domain-specific language (DSL)
for data-plane algorithms.  \pktlanguage is an imperative language
with C-like syntax. The key abstraction in \pktlanguage is a {\em
  packet transaction} (\S\ref{s:transactions}): a sequential code
block that is atomic and isolated from other such code blocks. Packet
transactions provide a convenient programming model, because they
allow the programmer to focus on the operations needed for each packet
without worrying about other packets that are concurrently being
processed. To the best of our knowledge, \pktlanguage is the first
high-level imperative language for programming the data plane of
line-rate switches.

In designing and implementing \pktlanguage, we make three contributions.
\begin{CompactEnumerate}
\item A family of machine models called \absmachine~(\S\ref{s:absmachine}).
    \absmachine generalizes and abstracts essential features of
line-rate programmable switches~\cite{rmt, xpliant, flexpipe}. \absmachine also
models practical constraints that limit stateful operations on line-rate
switches.  Informed by these constraints, we introduce the concept of {\em
atoms} to represent a programmable switch's instruction set.

\item A compiler to compile from packet transactions written in \pktlanguage
to a \absmachine target~(\S\ref{s:compiler}). The \pktlanguage compiler introduces
\textit{all-or-nothing compilation}, where all packet transactions accepted by
the compiler will run at line rate, or be rejected outright. There is no
``slippery slope'' of degrading performance with increasing code complexity.

\item An evaluation of \pktlanguage. We evaluate \pktlanguage's expressiveness
  by writing algorithms such as RCP~\cite{rcp}, CoDel~\cite{codel},
  heavy-hitter detection~\cite{opensketch}, and CONGA~\cite{conga}, in
  \pktlanguage~(\S\ref{s:eval}), and comparing it to P4.  Quantitatively, code
  in \pktlanguage is more concise. Qualitatively, \pktlanguage provides an
  easier and less error-prone model for programming stateful data-plane
  algorithms.  Next, because the infrastructure to program programmable
  switches is still heavily in development and no existing programmable switch
  supports the rich set of atoms required for our data-plane algorithms, we
  design a set of compiler targets (\S\ref{ss:targets}) based on \absmachine
  and show that these are feasible in a 32 nm standard-cell library with modest
  chip area overhead (< 10\%).  Finally, we compile data-plane algorithms
  written in \pktlanguage to these targets to show how the choice of atoms in a
  target determines which algorithms it can support.
\end{CompactEnumerate}

Overall, we stress two main takeaways. One, it is possible to design
programmable line-rate switches that can express a wide variety of data-plane
algorithms with modest overhead. Second, these switches can be programmed using
a high-level DSL without giving up any performance.
