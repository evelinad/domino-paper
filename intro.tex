\section{Introduction}
\label{s:intro}

%to support an evolving set of network protocols.
Network switches and routers in modern datacenters, enterprises, and
service-provider networks perform many tasks in addition to standard packet
forwarding. The set of requirements for routers has only increased with time as
network operators seek greater control over performance and security.
Performance and security may be improved using both data-plane and
control-plane mechanisms. This paper focuses on data-plane algorithms. These
algorithms process every data packet, transforming the packet and often also
some state maintained in the switch.  Examples of such algorithms include
congestion control with switch feedback~\cite{xcp, rcp, pdq, dctcp},
active-queue management~\cite{red,blue,avq,codel,pie}, network
measurement~\cite{opensketch, bitmap_george, elephant_george}, and
load-balanced routing in the data plane~\cite{conga}.

Because data-plane algorithms process every packet, an important requirement is
the ability to process packets at the switch's line rate.  As a result, these
algorithms are typically implemented using dedicated hardware. However,
hardware designs are rigid and prevent reconfigurability in the field. They
make it difficult to implement and deploy new algorithms without investing in
new hardware---a time-consuming and expensive proposition.

This rigidity affects vendors~\cite{cisco_nexus, dell_force10, arista_7050}
building network switches with merchant-silicon chips~\cite{trident, tomahawk,
mellanox}, network operators deploying switches~\cite{google,facebook,vl2}, and
researchers developing new switch algorithms~\cite{xcp, codel, d3, detail,
pdq}.  To run data-plane algorithms after a switch has been built, researchers
and companies have attempted to build programmable routers for many years,
starting from efforts on active networks~\cite{active-nets} to network
processors~\cite{npu_survey} to software routers~\cite{click,routebricks,
fastpass, flexplane}. All these efforts have compromised on speed to provide
programmability, typically running an order of magnitude (or worse) slower than
hardware line rates. Unfortunately, this reduction in performance has meant
that these systems are rarely deployed in production networks, if at all.

Programmable switching chips~\cite{flexpipe, xpliant, rmt, corsa, uadp,
algo_logic}, which are competitive with state-of-the-art fixed-function
chipsets~\cite{trident, tomahawk, mellanox}, are rapidly emerging as an
alternative. These chips implement a few low-level hardware primitives that can
be configured by software into a processing
pipeline~\cite{xpliant_sdk,xpliant_sdk2,intel_sdk}.  This approach is
attractive because it does not compromise on data rates and adds modest area
overhead for programmability~\cite{rmt}. From an operational standpoint, these
chips permit field reconfigurability, a feature that several other
computational substrates like CPUs, GPUs, DSPs have benefited from for many
years now.

P4~\cite{p4, p4spec} is an emerging packet-processing language for such chips.
P4 allows the programmer to specify packet parsing and processing without
restricting the set of protocol formats or the set of actions that can be
executed when matching packet headers in a match-action table. Data-plane tasks
that require large amounts of header rewriting can be expressed naturally in
P4~\cite{dc_p4}.

By contrast, many data-plane algorithms minimally manipulate headers, but
instead spend most of their time manipulating internal switch state in a manner
unique to each algorithm. We believe that network programmers would prefer the
convenience of an imperative language such as C that directly captures the
algorithm's intent without shoehorning algorithms into hardware constructs such
as a sequence of match-action tables like P4 does.  Furthermore, this is how
such algorithms are expressed in pseudocode~\cite{red, csfq, codel_code, avq,
blue}, and implemented in sofware routers~\cite{click, dpdk, routebricks},
network processors~\cite{packetc, nova}, and at network endpoints~\cite{qdisc}.

This paper presents \pktlanguage, a new domain-specific language (DSL) for
data-plane algorithms.  \pktlanguage is an imperative language with C-like
syntax. The key abstraction in \pktlanguage is a {\em packet transaction}
(\S\ref{s:transactions}): a sequential code block that is atomic and isolated
from other such code blocks. Packet transactions provide a convenient
programming model, because they allow the programmer to focus on the operations
needed for each packet without worrying about other packets that are
concurrently being processed. To the best of our knowledge, \pktlanguage is the
first high-level imperative language for programming the data plane of
line-rate switches.

%%
%%Atoms provide hardware support for packet transactions
%%similar to how an atomic test-and-set instruction in harware can implement an
%%atomic increment in software.
%%

In designing and implementing \pktlanguage, we make three contributions.
First, we design a family of abstract machines called
\absmachine~(\S\ref{s:absmachine}) (for Protocol-Independent Switch
Architecture). \absmachine generalizes and abstracts essential features of
line-rate programmable switches~\cite{rmt, xpliant, flexpipe}. \absmachine also
models practical constraints that limit stateful operations on line-rate
switches.  Informed by these constraints, we introduce the concept of {\em
atoms} to represent a programmable switch's instruction set.  Second, we
provide a programming model based on packet
transactions~(\S\ref{s:transactions}).  This model introduces
\textit{all-or-nothing compilation}, where all packet transactions accepted by
the compiler will run at line rate, or be rejected outright. There is no
``slippery slope'' of degrading performance with increasing code complexity.
Third, we implement a compiler~(\S\ref{s:compiler}) to compile packet
transactions to \absmachine machines. Our compiler adapts compiler techniques
to the new domain of line-rate switches, simplifying many of them in the
process (Table~\ref{tab:prior_compiler}).

We evaluate \pktlanguage in three ways~(\S\ref{s:eval}). First, we evaluate its
expressiveness by writing algorithms such as RCP~\cite{rcp},
CoDel~\cite{codel}, heavy-hitter detection~\cite{opensketch}, and
CONGA~\cite{conga}, in \pktlanguage~(\S\ref{s:eval}), and comparing it to
writing these algorithms in P4. Quantitatively, code in \pktlanguage is between
3 and 8$\times$ more concise. Qualitatively, \pktlanguage provides an easier
and less error-prone model for programming stateful data-plane algorithms.
Second, we design a set of compiler targets (\S\ref{ss:targets}) based on
\absmachine and show that these are feasible in a 32 nm standard-cell library
with modest chip area overhead (< 10\%). Third, we compile several data-plane
algorithms to these targets to show how the choice of atoms in a target
determines which algorithms it can support.

Overall, we stress two main takeaways. One, it is possible to design
programmable line-rate switches that can express a wide variety of data-plane
algorithms with modest overhead. Second, these switches can be programmed using
a high-level DSL without giving up any performance.
