\section{Introduction}
\label{s:intro}

Data-plane algorithms~\cite{cestan} are algorithms that are implemented within
a network switch. These algorithms process every data packet that passes
through the switch, transforming the packet and often also some state stored on
the switch.  Examples of such algorithms include congestion-control that uses
feedback from switches~\cite{xcp, rcp, pdq, dctcp}, active queue
management~\cite{codel}, network measurement~\cite{opensketch, bitmap_george,
elephant_george}, and load-balanced routing in the data plane~\cite{conga}.

Because data-plane algorithms process every packet, an important implementation
requirement is the ability to process packets at line rate.  Consequently,
these algorithms are primarily implemented using dedicated hardware. However,
hardware designs are rigid, making it difficult to experiment with new
algorithms.

This rigidity affects network switch vendors that build network
equipment~\cite{cisco_nexus, dell_force10, arista_7050} based on
merchant-silicon switching chips~\cite{trident, tomahawk, mellanox}, network
operators using such chips within private networks~\cite{google,facebook,vl2},
and researchers developing new switch algorithms~\cite{xcp, codel, d3, detail,
pdq}. Today, the only way to implement a new data-plane algorithm at line rate
is to expressly build hardware for it---a time-consuming and resource-intensive
process.

Programmable switching chips~\cite{flexpipe, xpliant, rmt}, which are
competitive with state of the art fixed-function chipsets~\cite{trident,
tomahawk, mellanox}, have emerged as an alternative.  These chips allow network
programmers to express their algorithms using primitives provided by the chip.
Programming these chips has become more user-friendly over time. Initial
attempts used proprietary SDKs such as those from XPliant~\cite{xpliant_sdk,
xpliant_sdk2} and Intel~\cite{intel_sdk} that were closely tied to the
underlying hardware.  Over time, languages such as P4~\cite{p4, p4spec} have
raised the level of abstraction by providing a language that seeks to be
protocol and target independent.

For instance, P4's language constructs allow the programmer to specify the
headers in a packet, the packet's parse graph, the sequence of match-action
tables processing each packet, and the operations carried out within each
action when a packet is matched. This is a natural programming model for many
data-plane tasks that involve packet parsing and header manipulation, such as
handling new protocol formats, switching, forwarding, tunneling, and access
control~\cite{dc_p4}.

However, P4 today isn't suited for data-plane algorithms such as congestion
control and active queue management, which manipulate state stored on the
switch and have an algorithmic flavor capturing each algorithm's control logic.
For such data-plane algorithms, network programmers would prefer the convenience
of an imperative language that captures the intent of the algorithm, similar to how
such algorithms are implemented in sofware routers~\cite{click}, network
processors~\cite{packetc, nova}, and the Linux qdisc subsystem~\cite{qdisc}.

This paper presents \pktlanguage, a new DSL for expressing data-plane
algorithms. \pktlanguage is an imperative language based on C that allows
programmers to express data-plane algorithms using {\em packet transactions}
(\S\ref{s:transactions}).  Packet transactions provide the abstraction of a
sequential block of code that runs to completion on each packet before
executing on the next packet. This is a convenient programming model, because it
allows the programmer to focus on the operations needed for each packet without
worrying about other packets that are concurrently being processed.

We have implemented a compiler for \pktlanguage that compiles \pktlanguage
packet transactions and generates code for a family of abstract machines called
\absmachine~(\S\ref{s:absmachine}) (for Protocol-Independent Switch
Architecture). \absmachine generalizes recent work on the Reconfigurable Match
Table~\cite{rmt} model and captures essential features of programmable switch
architectures with line-rate performance~\cite{rmt, xpliant, flexpipe}.

In addition, \absmachine introduces the concept of {\em atoms} to represent
atomic computations provided natively by a \absmachine machine much like
load-link/store-conditional, compare-and-exchange, and packed-multiply-and-add
on x86 machines today~\cite{x86_manual}.  Atoms provide the underlying atomic
hardware operations required to implement the programmer's view of packet
transactions, similar to how an atomic test-and-set is used to implement an
atomic increment.
%A template of the atoms available in a \absmachine machine is provided to the
%\pktlanguage compiler for code generation.

The \pktlanguage compiler guarantees deterministic performance for packet
transactions: all packet transactions that are implementable on a given
\absmachine machine will run at line rate, or they will be rejected by the
compiler if the atoms provided by a \absmachine machine cannot implement the
programmer-supplied transaction.

To evaluate the usefulness of \pktlanguage, we use \pktlanguage to express
several data-plane algorithms~(\S\ref{s:eval}) such as flowlet
switching~\cite{flowlets}, data-plane bloom filters~\cite{bloom}, heavy-hitter
detection~\cite{opensketch}, and CONGA~\cite{conga}.  The \pktlanguage compiler
determines if each algorithm can run at line rate on several different
\absmachine machines that differ in the atoms they
provide~(Figure~\ref{fig:eval}).
%We
%place \pktlanguage in the context of related work~(\S\ref{s:related}) and
%conclude by outlining several areas for future work~(\S\ref{s:future}).
