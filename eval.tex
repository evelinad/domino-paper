\section{Evaluation}
\label{s:eval}

\begin{table*}[!t]
  \begin{scriptsize}
  \begin{tabular}{|p{0.15\textwidth}|p{0.8\textwidth}|}
  \hline
  Atom template & SKETCH shorthand\\
  \hline
  Write &
  {\begin{lstlisting}[style=customctable]
  x = mux2(pkt.f, ??);
  \end{lstlisting}} \\
  \hline
  Increment &
  {\begin{lstlisting}[style=customctable]
  x = mux3(x, pkt.f, ??) + mux2(1, 0);
  \end{lstlisting}} \\
  \hline
  ReadAddWrite &
  {\begin{lstlisting}[style=customctable]
  x = mux3(x, pkt.f, ??) + mux2(??, pkt.f);
  \end{lstlisting}} \\
  \hline
  \pbox{0.15\textwidth}
  {Predicated\\
  ReadAddWrite} &
  {\begin{lstlisting}[style=customctable]
  if(mux2(x, ??) rel_op mux3(pkt.f1, pkt.f2, ??)) {
    x = mux4(x, pkt.f1, pkt.f2, ??) + mux3(??, pkt.f1, pkt.f2);
  }
  \end{lstlisting}} \\
  \hline
  \pbox{0.15\textwidth}
  {If-Else\\
   ReadAddWrite} &
  {\begin{lstlisting}[style=customctable]
  if(mux2(x, ??) rel_op mux3(pkt.f1, pkt.f2, ??)) {
    x = mux4(x, pkt.f1, pkt.f2, ??) + mux3(??, pkt.f1, pkt.f2);
  } else {
    x = mux4(x, pkt.f1, pkt.f2, ??) + mux3(??, pkt.f1, pkt.f2)};
  }
  \end{lstlisting}} \\
  \hline
  Paired Updates &
  {\begin{lstlisting}[style=customctable]
  bit pred1 = mux3(x, y,  ??) rel_op mux3(pkt.f1, pkt.f2, ??);
  bit pred2 = mux3(x, y,  ??) rel_op mux3(pkt.f1, pkt.f2, ??);
  if (pred1) {
    x = mux4(x, pkt.f1, pkt.f2, ??) + mux3(??, pkt.f1, pkt.f2);
    y = mux4(y, pkt.f1, pkt.f2, ??) + mux3(??, pkt.f1, pkt.f2);
  } else if (pred2) {
    x = mux4(x, pkt.f1, pkt.f2, ??) + mux3(??, pkt.f1, pkt.f2);
    y = mux4(y, pkt.f1, pkt.f2, ??) + mux3(??, pkt.f1, pkt.f2);
  }
  \end{lstlisting}} \\
  \hline
  \end{tabular}
\end{scriptsize}
  \caption{Atom templates used in evaluation. rel\_op $\in \{<, >, != , ==\}$ stands for a relational operator. ?? refers to a SKETCH hole that can be filled in with an unsigned integer in the range $[0, 2^n]$.}
  \label{tab:templates}
\end{table*}

\begin{table*}[!t]
\begin{tabular}{|p{0.20\textwidth}|p{0.74\textwidth}|}
\hline
Algorithm & Stateful computation \\
\hline
Learning bloom filter & \pbox{0.74\textwidth}{Set membership bit on every packet.
                                              We ``learn'' a new packet by adding it to the set.}\\
\hline
%TODO: Ask Lavanya exactly how heavy hitters works.
Heavy Hitters~\cite{opensketch} & Increment Count-Min Sketch~\cite{cormode} on every packet \\
\hline
Flowlet switching~\cite{flowlets} & Update saved next hop if flowlet threshold is exceeded \\
\hline
RCP~\cite{rcp} & Accumulate RTT sum if RTT is under maximum allowable RTT \\
\hline
Periodic sampling & \pbox{0.74\textwidth}{Sample/Mark a packet if packet count reaches N; reset count at N.} \\
\hline
CONGA~\cite{conga} & \pbox{0.74\textwidth}{Update best path's utilization/id if we see a better path.\\
                                           Update best path utilization alone if it changes.} \\
\hline
\end{tabular}
\caption{Data-plane Algorithms}
\label{tab:algos}
\end{table*}

\begin{table*}[!t]
  \begin{tabular}{|p{0.20\textwidth}|p{0.04\textwidth}|p{0.09\textwidth}|p{0.14\textwidth}|p{0.14\textwidth}|p{0.14\textwidth}|p{0.05\textwidth}|}
  \hline
    & Write & Increment & ReadAddWrite & Predicated ReadAddWrite & IfElse ReadAddWrite & Paired Updates \\
  \hline
  Learning bloom filters & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark \\
  \hline
  Heavy hitters          & \xmark & \cmark & \cmark & \cmark & \cmark & \cmark \\
  \hline
  Flowlet switching      & \xmark & \xmark & \xmark & \cmark & \cmark & \cmark \\
  \hline
  RCP                    & \xmark & \xmark & \xmark & \cmark & \cmark & \cmark \\
  \hline
  Periodic sampling & \xmark & \xmark & \xmark & \xmark & \cmark & \cmark \\
  \hline
  CONGA                  & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark \\
  \hline
  \end{tabular}
\caption{Table summarizing algorithm implementability depending on the atoms provided by \absmachine}
\label{table:eval}
\end{table*}

%10. Alvin's feedback: Write about our experience writing these programs. Similar to Steven Chong's PLDI paper.
To evaluate \pktlanguage, we express several well-known data-plane algorithms
(Table~\ref{tab:algos}) using \pktlanguage and determine if they are
implementable on different \absmachine instances that differ in the stateful
atoms (Table~\ref{tab:templates}) that each provides.

\subsection{Experimental procedure}
As mentioned earlier, we consider only stateful atoms because we assume
three-address code instructions map one-to-one to stateless atoms for all
\absmachine instances. For simplicity, the stateful atoms we consider only
permit updates to state variables and forbid packet field updates that might be
mixed in with state updates. Assuming the \absmachine instance provides an atom
to read a state variable\footnote{We think this is reasonable because the
inability to read a state variable renders them meaningless!}, such packet
updates can be treated as stateless operations in subsequent pipeline stages.

To represent atoms succinctly using their atom templates in
Table~\ref{tab:templates}, we use a shorthand notation for SKETCH, using ``x''
and ``y'' for state variables, and using muxN(a1, a2, ..., aN) to represent a
configurable choice between N operands such as the choice made by the 2-to-1
multiplexer in Figure~\ref{fig:sketch}a.

Table~\ref{tab:templates} gradually increases the expressiveness of the
stateful atom provided by an \absmachine instance. These atoms form a
containment hierarchy: going from left to right in Table~\ref{table:eval}, each
atom is strictly more expressive than its predecessor to its left and hence can
express all algorithms that its predecessor can.

We now consider every atom from Table~\ref{tab:templates}, and every data-plane
algorithm from Table~\ref{tab:algos} to determine if each algorithm is
\textit{implementable} using a particular atom. We say an algorithm is
implementable using a particular atom if every stateful codelet within the
algorithm can be successfully mapped to that atom's template using the
procedure in \S\ref{ss:code_gen}.

\subsection{Interpreting these results}
Table~\ref{table:eval} presents our results. There are two ways to interpret
them. For a network programmer, the matrix in Table~\ref{table:eval} tells her
if a particular data-plane algorithm can be implemented at line rate after a
programmable switch has been built, assuming the \absmachine instance provides
a particular atom.

For an ASIC engineer designing programmable switching chips, the same table
describes the algorithms that are implementable with a particular atom. For
instance, the paired updates atom can implement all algorithms shown in
Table~\ref{table:eval}, while a simpler increment atom can implement only
two of the six algorithms.

These results will change as programmable switches evolve and network
programmers continuously push chip boundaries with new algorithms.  The larger
takeaway from this evaluation is that programming in \pktlanguage allows us to
rigorously determine if a particular high-level algorithm is implementable at
line rate using a particular atom and conversely, if a particular atom suffices
to implement a large number of algorithms.
