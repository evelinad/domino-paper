\section{Evaluation}
\label{s:eval}
\begin{table*}[!t]
  \begin{small}
  \begin{tabular}{|p{0.15\textwidth}|p{0.8\textwidth}|}
  \hline
  Atom template & SKETCH shorthand\\
  \hline
  Write &
  {\begin{lstlisting}[style=customc]
  x = mux2(pkt.f, ??);
  \end{lstlisting}} \\
  \hline
  Increment &
  {\begin{lstlisting}[style=customc]
  x = mux3(x, pkt.f, ??) + mux2(1, 0);
  \end{lstlisting}} \\
  \hline
  Read-Add-Write &
  {\begin{lstlisting}[style=customc]
  x = mux3(x, pkt.f, ??) + mux2(??, pkt.f);
  \end{lstlisting}} \\
  \hline
  \pbox{0.15\textwidth}
  {Predicated\\
  Read-Add-Write} &
  {\begin{lstlisting}[style=customc]
  if(mux2(x, ??) rel_op mux3(pkt.f1, pkt.f2, ??)) {
    x = mux4(x, pkt.f1, pkt.f2, ??) + mux3(??, pkt.f1, pkt.f2);
  }
  \end{lstlisting}} \\
  \hline
  \pbox{0.15\textwidth}
  {If-Else\\
   Read-Add-Write} &
  {\begin{lstlisting}[style=customc]
  if(mux2(x, ??) rel_op mux3(pkt.f1, pkt.f2, ??)) {
    x = mux4(x, pkt.f1, pkt.f2, ??) + mux3(??, pkt.f1, pkt.f2);
  } else {
    x = mux4(x, pkt.f1, pkt.f2, ??) + mux3(??, pkt.f1, pkt.f2)};
  }
  \end{lstlisting}} \\
  \hline
  Paired Updates &
  {\begin{lstlisting}[style=customc]
  bit pred1 = mux3(pkt.f1, pkt.f2, ??) rel_op mux3(x, y,  ??);
  bit pred2 = mux3(pkt.f1, pkt.f2, ??) rel_op mux3(x, y,  ??);
  if (pred1) {
    x = mux4(x, pkt.f1, pkt.f2, ??) + mux3(??, pkt.f1, pkt.f2);
    y = mux4(y, pkt.f1, pkt.f2, ??) + mux3(??, pkt.f1, pkt.f2);
  } else if (pred2) {
    x = mux4(x, pkt.f1, pkt.f2, ??) + mux3(??, pkt.f1, pkt.f2);
    y = mux4(y, pkt.f1, pkt.f2, ??) + mux3(??, pkt.f1, pkt.f2);
  }
  \end{lstlisting}} \\
  \hline
  \end{tabular}
\end{small}
  \caption{Atom templates used in evaluation. rel\_op $\in \{<, >, != , ==\}$ stands for a relational operator. ?? refers to a SKETCH hole that can be filled in with an unsigned integer in the range $[0, 2^n]$.}
  \label{tab:templates}
\end{table*}

%10. Alvin's feedback: Write about our experience writing these programs. Similar to Steven Chong's PLDI paper.
To evaluate \pktlanguage, we express several well-known data-plane algorithms
(CONGA~\cite{conga}, RCP~\cite{rcp}, bloom filters~\cite{bloom}, heavy hitter
detection~\cite{opensketch}, determinstic packet sampling and flowlet switching
~\cite{flowlets}) using \pktlanguage and determine if they are implementable,
for different \absmachine instances that differ in the stateful atom templates
that they provide.

We gradually increase the expressiveness of atom templates provided by
\pktlanguage and use the \pktlanguage compiler to determine whether a specific
algorithm is implementable assuming that atom template is provided by an
\absmachine instance. Below, we list out the atoms that we consider in
increasing order of expressiveness. As mentioned earlier, we consider only
stateful atom templates because converting into three-operand code generates
instructions that map one-to-one to \absmachine for stateless operations.

\subsection{Atoms considered}

We consider atom templates (Table~\ref{tab:templates}) with increasing
expressiveness and arrange them in a containment hierarchy: each atom is
strictly more expressive than its predecessor and hence can express all
algorithms that its predecessor could. To represent templates succinctly, we
use a shorthand notation, using ``x'' and ``y'' for state variables, and using
muxN(a1, a2, ..., aN) to represent a configurable choice between N operands
such as the choice made by the 2-to-1 multiplexer in Figure~\ref{fig:sketch}a.

Finally, for simplicity, the atom templates we consider only permit updates to
state variables and forbid packet field updates that might be mixed in with
state updates. Assuming the \absmachine instance provides an atom template to
at least read a state variable\footnote{We think this is reasonable because the
inability to read a state variable renders them meaningless!}, such packet
updates can always be treated as stateless operations in subsequent pipeline
stages.

\subsection{Data-plane algorithms considered}

We now consider every combination of atom templates in
Table~\ref{tab:templates}, and data-plane algorithm to determine if each
algorithm is implementable using a particular atom template.
Table~\ref{table:eval} presents our results as a matrix.

\begin{table*}[!t]
  \begin{center}
  \begin{tabular}{|p{0.29\textwidth}|p{0.04\textwidth}|p{0.09\textwidth}|p{0.09\textwidth}|p{0.09\textwidth}|p{0.09\textwidth}|p{0.09\textwidth}|}
  % Other atom templates: R/W, ++/--, ReadAddWrite, Predicated ReadAddWrite, Two-way predication, paired updates
  \hline
    & Write & Increment & Read-Add-Write & Predicated Read-Add-Write & If-Else Read-Add-Write & Paired Updates \\
  \hline
  Learning bloom filters & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark \\
  \hline
  Heavy hitters          & \xmark & \cmark & \cmark & \cmark & \cmark & \cmark \\
  \hline
  Flowlet switching      & \xmark & \xmark & \xmark & \cmark & \cmark & \cmark \\
  \hline
  RCP                    & \xmark & \xmark & \xmark & \cmark & \cmark & \cmark \\
  \hline
  Deterministic sampling & \xmark & \xmark & \xmark & \xmark & \cmark & \cmark \\
  \hline
  CONGA                  & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark \\
  \hline
  \end{tabular}
\end{center}
\label{table:eval}
\caption{Table summarizing algorithm implementability depending on the atoms provided by \absmachine}
\end{table*}
