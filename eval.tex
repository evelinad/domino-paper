\section{Evaluation}
% TODO: Is there a good technical reason why every \absmachine machine
% should have exactly one large stateful atom as opposed to many small stateful atoms?

% TODO: Show how pipeline width / depth changes
% by adding more complicated atoms? This might be a little more work though.

% TODO: Do we mention how we had to approximate CONGA? Another option is to create
% an appendix with all the algorithms written in domino.
\label{s:eval}

\begin{table}[!t]
  \begin{scriptsize}
  \begin{tabular}{|p{0.1\textwidth}|p{0.35\textwidth}|}
    \hline
    Atom & Description \\
    \hline
    Write & Write packet field/constant into single state variable. \\
    \hline
    ReadAddWrite (RAW) & Add packet field/constant to state variable (OR) Write packet field/constant into state variable. \\
    \hline
    Predicated ReadAddWrite (RAW) & Execute RAW on state variable only if a predicate is true, else leave unchanged. \\
    \hline
    IfElse ReadAddWrite (IfElseRAW) & Execute two separate RAWs: one each for when a predicate is true or false.\\
    \hline
    Subtract (Sub) & Same as IfElseRAW, but also allow subtracting a packet field/constant. \\
    \hline
    Nested Ifs (Nested) & Same as Sub, but with an additional level of nesting that provides 4-way predication. \\
    \hline
    Paired updates (Pairs) & Same as Nested, but allow updates to a pair of state variables, where predicates can use both state variables. \\
    \hline
  \end{tabular}
  \end{scriptsize}
  \caption{Atoms used in evaluation. Appendix A provides the SKETCH code and
  circuit diagrams for these atoms.}
  \label{tab:templates}
\end{table}

\begin{table}[!t]
  \begin{scriptsize}
    \begin{tabular}{|p{0.08\textwidth}|p{0.3\textwidth}|p{0.03\textwidth}|}
  \hline
  Atom & Circuit & Circuit depth \\
  \hline
  Write & \includegraphics[width=0.2\textwidth]{rw.pdf} & 1 \\
  \hline
  ReadAddWrite (RAW) & \includegraphics[width=0.2\textwidth]{raw.pdf} & 2\\
  \hline
  \pbox{0.1\textwidth}
  {Predicated\\
  ReadAddWrite (PRAW)} & \includegraphics[width=0.3\textwidth]{pred_raw.pdf}  & 3\\
  \hline
  \end{tabular}
\end{scriptsize}
\caption{Circuit depth and propagation delay increases with complexity of atoms.}
  \label{fig:circuit_depth}
\end{table}

\begin{table*}[!t]
  \begin{tabular}{|p{0.16\textwidth}|p{0.47\textwidth}|p{0.09\textwidth}|p{0.06\textwidth}|p{0.07\textwidth}|}
\hline
Algorithm & Stateful computation & Least expressive atom & Pipeline depth, width & Ingress or Egress Pipeline?\\
\hline
\pbox{0.16\textwidth}{Bloom filter~\cite{bloom}\\(3 hash functions)} & \pbox{0.54\textwidth}{Set membership bit on every packet.} & Write & 4, 3 & Either \\
\hline
\pbox{0.16\textwidth}{Heavy Hitters~\cite{opensketch}\\(3 hash functions)} & Increment Count-Min Sketch~\cite{cormode} on every packet. & RAW & 10, 9 & Either \\
\hline
Flowlets~\cite{flowlets} & Update saved next hop if flowlet threshold is exceeded. & PRAW & 6, 2 & Ingress \\
\hline
RCP~\cite{rcp} & \pbox{0.47\textwidth}{Accumulate RTT sum if\\RTT is under maximum allowable RTT.} & PRAW & 3, 3 & Egress \\
\hline
\pbox{0.16\textwidth}{Sampled\\NetFlow~\cite{sampled_nflow}} & \pbox{0.47\textwidth}{Sample a packet if packet count reaches N;\\Reset count to 0 when it reaches N.} & IfElseRAW & 4, 2 & Either\\
\hline
HULL~\cite{hull} & Update counter for virtual queue. & Sub & 7, 1 & Egress \\
\hline
\pbox{0.16\textwidth}{Adaptive\\Virtual Queue~\cite{avq}} & Update virtual queue size and virtual capacity & Nested & 7, 3 & Ingress \\
\hline
CONGA~\cite{conga} & \pbox{0.54\textwidth}{Update best path's utilization/id if we see a better path.\\
                                           Update best path utilization alone if it changes.}  & Pairs & 4, 2 & Ingress\\
\hline
trTCM~\cite{trTCM} & Update token counts for each token bucket & Doesn't map & 7, 3 & Either \\
\hline
CoDel~\cite{codel} & \pbox{0.54\textwidth}{Update:\\Whether we are marking or not.\\Time for next mark.\\Number of marks so far.\\Time at which min. queuing delay will exceed target.}& Doesn't map & 15, 3 & Egress \\
\hline
\end{tabular}
\caption{Data-plane algorithms}
\label{tab:algos}
\end{table*}

To evaluate \pktlanguage, we express several data-plane algorithms
(Table~\ref{tab:algos}) using \pktlanguage and determine if they are
implementable on different \absmachine machines that provide different stateful
atoms (Table~\ref{tab:templates}). Appendix A contains circuit diagrams and
SKETCH code for these atoms.

We expressed most data-plane algorithms in \pktlanguage by simply translating
their imperative code/pseudocode to \pktlanguage. We did, however, modify
CoDel. Because CoDel drops from the head of a queue, it uses a
loop~\cite{codel_code} to repeatedly dequeue packets until it can send one out.
We replaced the loop with an if statement and mark packets instead of dropping
them. This reflects the reality that a switch running at line rate can dequeue
packets exactly once. Dropping these dequeued packets, instead of marking them,
leads to an idle line and wasted capacity.

\subsection{Experimental procedure}
As mentioned in \S\ref{ss:code_gen}, we consider only stateful atoms and assume
stateless codelets map one-to-one to stateless atoms for all \absmachine
machines. For simplicity, the stateful atoms only permit updates to state
variables and forbid packet field updates mixed in with these state updates.
Assuming the \absmachine machine provides an atom to read a state
variable\footnote{The inability to read a state variable renders it
powerless!}, such field updates can be treated as stateless operations in
subsequent pipeline stages.

We also assume every \absmachine machine provides exactly one kind of stateful
atom although we don't restrict the number of instances of this stateful atom.
Table~\ref{tab:templates} gradually increases the capability of this single
atom.  We designed the atoms in Table~\ref{tab:templates}, and hence the
\absmachine machines providing them, to form a containment hierarchy: each atom
can express all data-plane algorithms that its predecessor can.

We now consider every atom/\absmachine machine from Table~\ref{tab:templates},
and every data-plane algorithm from Table~\ref{tab:algos} to determine if the
algorithm is \textit{implementable} on a particular \absmachine machine. We say
an algorithm is implementable on a \absmachine machine, if every stateful
codelet within the data-plane algorithm can be mapped (\S\ref{ss:code_gen}) to
the stateful atom provided by the \absmachine machine. Because atoms are
arranged in a containment hierarchy, we list the \textit{least expressive} atom
that can be used to implement a data-plane algorithm in Table~\ref{tab:algos}.

\subsection{Interpreting the results}
Table~\ref{tab:algos} tells a network programmer the minimal atom required to
run a data-plane algorithm at line rate. For an ASIC engineer designing
programmable switches, the same table describes the algorithms that are
implementable on a \absmachine machine with a specific stateful atom. For
instance, a \absmachine machine with the Pairs atom can implement the first
eight algorithms, while a machine with a simpler RAW atom can implement only
the first two.

We also extract broader lessons for designing programmable switching chips.
First, atoms supporting stateful operations on a single state variable are
sufficient for several data-plane algorithms (Bloom Filters through AVQ in
Table~\ref{tab:algos}). However, there are algorithms that need the ability to
update a pair of state variables based on the previous value of the pair. One
example is CONGA, whose code we reproduce below:
\begin{verbatim}
  if (p.util < best_path_util[p.src]) {
    best_path_util[p.src] = p.util;
    best_path[p.src] = p.path_id;
  } else if (p.path_id == best_path[p.src]) {
    best_path_util[p.src] = p.util;
  }
\end{verbatim}
Here, \texttt{best\_path} (the ID of the best path for a particular
destination) is updated conditioned on \texttt{best\_path\_util} (the
utilization of the best path to that destination)\footnote{p.src is the address
  of the host originating this utilization message, and hence the
destintation for the host receiving it and executing the CONGA algorithm.} and
vice versa. There is no way to separate the two state variables into separate
stages and guarantee correctness.
%TODO: Mihai: Add figure of CONGA here maybe?

The Pairs atom, where the update to a state variable is conditioned on a
predicate of a pair of state variables, allows us to implement CONGA at line
rate.  However, it is still insufficient for some algorithms. Algorithms such
as CoDel~\cite{codel} and the two-rate three-color meter~\cite{trTCM}(trTCM)
can still not run at line rate---even if a Pairs atom is available.

On a positive note, however, the codelets in both trTCM and CoDel are still
restricted to a pair of state variables.  We haven't yet encountered a case
where a triplet of state variables all fall in the same strongly connected
component/codelet, requiring a three-way state update.  We leave the problem of
approximating CoDel/trTCM to fit within a particular atom or conversely,
designing more complex atoms to support them to future work.

While an expressive atom is better for mapping more data-plane algorithms, it
does have a cost. A larger and more expressive atom takes up more gate area
when synthesized to a digital circuit and results in longer propagation delays.
As an illustration, consider the circuits for the first three atoms from Table
~\ref{tab:templates} shown in Figure~\ref{fig:circuit_depth}. We use the number
of elements that a wire has to pass through between input and output (the
circuit depth) as a proxy for propagation delay. We see that the circuit depth
increases as we add complexity to atoms. At some point, the propagation delay
may be large enough that the resulting circuit may not meet timing to sustain a
particular line rate. We plan to synthesize these atoms to circuits in a
standard cell library to study this further.

These results will change as programmable switches evolve and network
programmers push chip boundaries with new algorithms.  The larger takeaway is
that we can now begin to quantify the programmability-performance tradeoff that
chip designers have so far intuitively understood. Using the \pktlanguage
compiler, we can rigorously\footnote{Modulo inefficiencies in the compiler
itself.} determine if a particular set of data-plane algorithms can run at a
given line rate, given the atoms supported by the \absmachine machine at that
line rate.

%TODO: This isn't written as strongly as we could write this.
% Not sure whether we want to have this at all.
\subsection{Compilation times}
The data-plane algorithms that we consider are all under 100 LOC. Hence, our
front-end compilation times are negligible; compilation times are dominated by
SKETCH trying to map codelets to atoms. However, we limit the bit-width of
SKETCH holes to 5 bits because the constants we see in our algorithms are
small.  This reduces the search space for SKETCH.  The worst-case occurs when a
large algorithm does not map to a large atom, because then SKETCH has to rule
out every possible configuration. Quantitatively, our worst-case compilation
time is 10 seconds when CoDel doesn't map to a \absmachine machine with the
Pairs atom.  This time will increase if we increase the bit width of constants
that SKETCH has to search; howerver, because the data-plane algorithms are
themselves small, we don't anticipate compilation times being a concern.
