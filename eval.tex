\section{Evaluation}
\label{s:eval}

\begin{table}[!t]
  \begin{scriptsize}
  \begin{tabular}{|p{0.13\textwidth}|p{0.22\textwidth}|p{0.04\textwidth}|}
    \hline
    Atom & Description & Area (\si{\micro\metre\squared})\\
    \hline
    Stateless & Arithmetic, logic, relational, and conditional operations on packet/constant operands & 1384 \\
    \hline
    Read/Write & Read/Write packet field/constant into single state variable. & 250 \\
    \hline
    ReadAddWrite (RAW) & Add packet field/constant to state variable (OR) Write packet field/constant into state variable. & 431 \\
    \hline
    Predicated ReadAddWrite (RAW) & Execute RAW on state variable only if a predicate is true, else leave unchanged. & 791 \\
    \hline
    IfElse ReadAddWrite (IfElseRAW) & Two separate RAWs: one each for when a predicate is true or false. & 985 \\
    \hline
    Subtract (Sub) & Same as IfElseRAW, but also allow subtracting a packet field/constant. & 1522 \\
    \hline
    Nested Ifs (Nested) & Same as Sub, but with an additional level of nesting that provides 4-way predication. & 3597 \\
    \hline
    Paired updates (Pairs) & Same as Nested, but allow updates to a pair of state variables, where predicates can use both state variables. & 5997 \\
    \hline
  \end{tabular}
  \end{scriptsize}
  \caption{Atom areas in a 32 nm standard-cell library.  All atoms meet timing
  at 1GHz. Each of the seven compiler targets contains one of the seven
  stateful atoms (Read/Write through Pairs) and the single stateless atom.}
  \label{tab:templates}
\end{table}

\begin{table*}[!t]
  \begin{tabular}{|p{0.16\textwidth}|p{0.34\textwidth}|p{0.08\textwidth}|p{0.09\textwidth}|p{0.07\textwidth}|p{0.06\textwidth}|p{0.05\textwidth}|}
\hline
Algorithm & Description & Least expressive atom & \# of stages, max. atoms/stage & Ingress or Egress Pipeline? & Domino LOC & P4 LOC\\
\hline
\pbox{0.16\textwidth}{Bloom filter~\cite{bloom}\\(3 hash functions)} & \pbox{0.54\textwidth}{Set membership bit on every packet.} & Write & 4, 3 & Either & 29 & 104 \\
\hline
\pbox{0.16\textwidth}{Heavy Hitters~\cite{opensketch}\\(3 hash functions)} & Increment Count-Min Sketch~\cite{cormode} on every packet. & RAW & 10, 9 & Either & 35 & 192 \\
\hline
Flowlets~\cite{flowlets} & Update saved next hop if flowlet threshold is exceeded. & PRAW & 6, 2 & Ingress & 37 & 107 \\
\hline
RCP~\cite{rcp} & \pbox{0.34\textwidth}{Accumulate RTT sum if\\RTT is under maximum allowable RTT.} & PRAW & 3, 3 & Egress & 23 & 75 \\
\hline
\pbox{0.16\textwidth}{Sampled\\NetFlow~\cite{sampled_nflow}} & \pbox{0.47\textwidth}{Sample a packet if packet count reaches N;\\Reset count to 0 when it reaches N.} & IfElseRAW & 4, 2 & Either  & 18 & 70 \\
\hline
HULL~\cite{hull} & Update counter for virtual queue. & Sub & 7, 1 & Egress & 26 & 95 \\
\hline
\pbox{0.16\textwidth}{Adaptive\\Virtual Queue~\cite{avq}} & Update virtual queue size and virtual capacity & Nested & 7, 3 & Ingress & 36 & 147 \\
\hline
\pbox{0.16\textwidth}{Priority computation for weighted fair queueing~\cite{pifo_hotnets}} & Compute packet's virtual start time using finish time of last packet in that flow. & Nested & 4, 2 & Ingress & 29 & 87 \\
\hline
\pbox{0.16\textwidth}{DNS TTL change tracking~\cite{dns_change}} & Track number of changes in announced TTL for each domain & Nested & 6,3 & Ingress & 27 & 119 \\
\hline
CONGA~\cite{conga} & \pbox{0.34\textwidth}{Update best path's utilization/id if we see a better path.\\
                                           Update best path utilization alone if it changes.}  & Pairs & 4, 2 & Ingress & 32 & 89\\
\hline
CoDel~\cite{codel} & \pbox{0.34\textwidth}{Update:\\Whether we are marking or not.\\Time for next mark.\\Number of marks so far.\\Time at which min. queueing delay will exceed target.}& Doesn't map & 15, 3 & Egress & 57 & 271\\
\hline
\end{tabular}
\caption{Data-plane algorithms}
\label{tab:algos}
\end{table*}

We have performed a number of experiments to evaluate \pktlanguage. 
First, we evaluate \pktlanguage's expressiveness by using it to program several
data-plane algorithms (Table~\ref{tab:algos}), and comparing it to writing them
in P4~(\S\ref{ss:expressiveness}).  To validate that these algorithms can be
implemented at line rate, we design a concrete set of \absmachine machines that
we use as compiler targets for \pktlanguage~(\S\ref{ss:targets}).  We estimate
that these machines are feasible in hardware today because their atoms incur
modest chip area overhead. Next, we use the \pktlanguage compiler to compile
the algorithms in Table~\ref{tab:algos} to these targets~(\S\ref{ss:compiler}).
We conclude by quantifying the tradeoff between a target's programmability (the
space of data-plane algorithms that it can run at line rate) and the target's
performance (the maximum line rate it can support)~(\S\ref{ss:perfprog}).

\subsection{Expressiveness}
\label{ss:expressiveness}

To evaluate \pktlanguage's expressiveness, we express several data-plane
algorithms (Table~\ref{tab:algos}) using \pktlanguage. These algorithms
encompass a variety of data-plane functionality including data-plane load
balancing, in-network congestion control, active queue management, security,
and measurement. In addition, we also used Domino to express the priority
computation for programming scheduling using the push-in first-out queue
abstraction~\cite{pifo_hotnets}. In all these cases, the algorithms are
already available as blocks of imperative code from online sources; 
translating them to \pktlanguage syntax
was straightforward.

In contrast, expressing any of these algorithms in P4 requires manually teasing
out portions of the algorithm that can reside in independent match-action
tables and then chaining these tables together. In essence, the programmer
manually carries out the transformations in \pktlanguage's compiler. Of the
algorithms in Table~\ref{tab:algos}, only flowlet switching has a publicly
available P4 implementation~\cite{p4_flowlet} that we can compare against. This
implementation requires 231 lines of uncommented P4, in comparison to the 37
lines of \pktlanguage code in Figure~\ref{fig:flowlet_code}. Not only that,
using P4 also requires the programmer to manually specify tables, the actions
within the tables, how tables are chained, and what headers are required---all
to implement a single data-plane algorithm. As the \pktlanguage compiler shows,
this process can be automated; to demonstrate this, we developed a backend for
\pktlanguage that generates the equivalent P4 code (lines of code for these auto-generated P4
programs are listed in Table~\ref{tab:algos}).

Lastly, data-plane algorithms on software platforms today (NPUs,
Click~\cite{click}, the Linux qdisc subsystem~\cite{qdisc})  are programmed in languages
resembling \pktlanguage---hence we are confident that the \pktlanguage
syntax is already familiar to network operators.

\subsection{Compiler targets}
\label{ss:targets}

We design a concrete set of compiler targets for \pktlanguage based on the
\absmachine machine model. First, we specify computational limits on atoms in
each compiler target using atom templates. Using the Synopsys Design
Compiler~\cite{synopsys_dc}, we quantify each atom's area in a 32 nm
standard-cell library when running at 1 GHz.  Second, using an individual
atom's area and a switching chip's area~\cite{gibb_parsing}, we determine the
machine's resource limits, i.e., the pipeline width for each atom and the
pipeline depth.

\textbf{Computational limits:}
Stateless atoms are easier to design because arbitrary stateless operations can
be spread out across multiple pipeline stages without violating
atomicity~(\S\ref{ss:atoms}). We design a stateless atom that can support
simple arithmetic (add, subtract, left shift, right shift), logical (and, or,
xor), relational ({\tt >=}, {\tt <=}, {\tt ==}, {\tt !=}), or conditional operations (C's ``{\tt ?}''
operator) on a set of packet fields. Any packet field can also be substituted
with a constant operand.

Designing stateful atoms is more involved because it determines which
algorithms the switch can support. A more complex stateful atom can support
more data-plane algorithms, but occupies greater chip area. To illustrate this,
we design a containment hierarchy of stateful atoms, where each atom can
express all stateful operations that its predecessor can. When synthesized to a
32 nm standard-cell library, all of our designed atoms meet timing at 1 GHz and their area
increases with the atom's complexity~(Table~\ref{tab:templates}).

\textbf{Resource limits:}
We design one compiler target for each combination of a stateful atom along
with the single stateless atom in Table~\ref{tab:templates}.  We determine
resource limits for stateful and stateless atoms separately.  For the stateless
atom, assuming a chip area of 200 \si{\milli\metre\squared} (the smallest area given by Gibb et
al.~\cite{gibb_parsing}), and an acceptable overhead of 7\% (the area overheads
for actions in RMT~\cite{rmt}), we can support \textasciitilde10000 stateless atoms, given
the area of 1384 \si{\micro\metre\squared} per instance.  If these 10000 atoms were
spread across the same number of stages (32) as RMT, we could support up to
\textasciitilde300 stateless atoms per stage.

A similar analysis for the stateful atoms yields 70 stateful atoms per stage for
the most complex stateful atom (Pairs) with an area of 5997 \si{\micro\metre\squared}.
However, stateful atoms access per-stage memory banks storing state.
Providing 70 independent memory banks per stage supporting one read and
write per clock is prohibitive. Furthermore, given an overall stage memory budget,
slicing it into many small banks reduces the amount of memory accessible to
each atom. This is problematic for hash-based algorithms that need to hash into
a large memory space. Taking these into account, we limit the number of
stateful atoms to around 10 per stage, which is still sufficient for the
data-plane algorithms that we are interested in. The area overhead of these 10
stateful atoms is \textasciitilde1\%.

We next look at the multiplexers to route inputs to these atoms from specific
packet fields and route outputs from these atoms to specific packet fields. For
this, we rely on RMT~\cite{rmt}, which estimates a crossbar area of 6 \si{\milli\metre\squared}
for a 32-stage pipeline with 224 action units. Scaling this proportionally to
300 atoms, we estimate a crossbar area of 8 \si{\milli\metre\squared} with a 4\% area
overhead.

In summary, we assume 32 stages in total, 300 stateless atoms per stage and 10
stateful atoms per stage for all compiler targets with an area overhead of 12\%
(7\% for stateless atoms, 1\% for the stateful atoms, and 4\% for the
crossbars). By no means is this the only design. We only claim that this is
feasible and show that it can be used to implement a variety of data-plane
algorithms, which is far beyond a fixed-function switch today. We anticipate
\absmachine machines evolving as data-plane algorithms demand more of
the hardware.

\subsection{Compiling \pktlanguage programs to \absmachine machines}
\label{ss:compiler}
We now consider every target from Table~\ref{tab:templates}, and every
data-plane algorithm from Table~\ref{tab:algos} to determine if the algorithm
can run at line rate on a particular \absmachine machine. We say an algorithm
can run at line rate on a \absmachine machine if every codelet within the
data-plane algorithm can be mapped (\S\ref{ss:code_gen}) to either the stateful
or stateless atom provided by the \absmachine machine. Because stateful atoms
are arranged in a containment hierarchy, we list the \textit{least expressive}
stateful atom/target required for each data-plane algorithm in
Table~\ref{tab:algos}.

We note two lessons for designing programmable
switches from Table~\ref{tab:algos}.
First, atoms supporting stateful operations on a single state
variable are sufficient for several data-plane algorithms. For instance, the
algorithms from Bloom Filter through DNS TTL Change Tracking in
Table~\ref{tab:algos} can be run at line rate using the Nested Ifs atom that
manipulates a single state variable. Second, there are algorithms that need
to update a pair of state variables atomically. One example is CONGA,
whose code we reproduce below:
\begin{verbatim}
  if (p.util < best_path_util[p.src]) {
    best_path_util[p.src] = p.util;
    best_path[p.src] = p.path_id;
  } else if (p.path_id == best_path[p.src]) {
    best_path_util[p.src] = p.util;
  }
\end{verbatim}
Here, \texttt{best\_path} (the path id of the best path for a particular
destination) is updated conditioned on \texttt{best\_path\_util} (the
utilization of the best path to that destination)\footnote{{\tt p.src} is the
  address of the host originating this message, and hence the destination for
the host receiving it and executing CONGA.} and vice versa. These two state
variables cannot be separated into different stages and still guarantee a
packet transaction's semantics. The Pairs atom, where the update to a state
variable is conditioned on a predicate of a pair of state variables, allows us
to run CONGA at line rate.

While the targets in Table~\ref{tab:templates} are sufficient for several
data-plane algorithms, there are algorithms that they can't run at line rate.
An example is CoDel, which cannot be implemented because it requires a square
root operation that isn't provided by any of our targets. One possibility is a
look-up table abstraction that allows us to approximate such
mathematical functions. We leave this exploration to future work.

\textbf{Compilation time:}
Compilation time is dominated by SKETCH's search procedure.  To speed up the
search, we limit SKETCH to search for constants (e.g., for addition) of size up
to 5 bits, given that the constants seen within stateful codelets in our
algorithms are small. Our longest compilation time is 10 seconds when CoDel
doesn't map to a \absmachine machine with the Pairs atom because SKETCH has to
rule out every configuration in its search space.  This time will increase if
we increase the bit width of constants that SKETCH has to search; however,
because the data-plane algorithms themselves are small, we don't expect
compilation times to be a concern.

\subsection{Performance vs. programmability}
\label{ss:perfprog}
While powerful atoms like Pairs can implement more data-plane algorithms, they
have a performance cost.  A more expressive atom incurs longer signal
propagation delays and implies a lower clock frequency or line rate
(the inverse of propagation delay).  To quantify
this intuition, we consider each stateful atom from Table~\ref{tab:templates}
and synthesize a circuit with the lowest possible delay. As we increase the
complexity of the atom, the number of algorithms from Table~\ref{tab:algos}
that it can implement increases (programmability), while at the same time, its
achievable line rate (performance) decreases
(Table~\ref{tab:perfprog}).\footnote{The slightly non-monotonic behavior
between PRAW and IfElseRAW is because the logic synthesis tool is not optimal
and employs many heuristics.} This decrease in line rate can be explained by
looking at the simplified circuit diagrams for the first three atoms
(Table~\ref{tab:circuits}), which show an increase in circuit depth with atom
complexity.

\begin{table}[!t]
  \begin{scriptsize}
  \begin{tabular}{|p{0.08\textwidth}|p{0.12\textwidth}|p{0.09\textwidth}|p{0.09\textwidth}|}
  \hline
  Atom & Min. delay (picoseconds) & Programmability (\# of algorithms implemented by atom) & Performance (Max. line rate in billion pkts/sec) \\
  \hline
  Write & 176 & 1  & 5.68 \\
  \hline
  ReadAddWrite (RAW) & 316 & 2 & 3.16\\
  \hline
  \pbox{0.1\textwidth}
  {Predicated\\
  ReadAddWrite (PRAW)} & 393 & 4 & 2.54 \\
  \hline
  IfElse ReadAddWrite (IfElseRAW) & 392 & 5 & 2.55 \\
  \hline
  Subtract (Sub) & 409 & 6 & 2.44 \\
  \hline
  Nested Ifs (Nested) & 580 & 9 & 1.72 \\
  \hline
  Paired updates (Pairs) & 609 & 10 & 1.64 \\
  \hline
  \end{tabular}
\end{scriptsize}
\caption{Programmability increases with more complex atoms,
  but performance decreases.}
\label{tab:perfprog}
\end{table}

\begin{table}[!t]
  \begin{scriptsize}
    \begin{tabular}{|p{0.08\textwidth}|p{0.28\textwidth}|p{0.05\textwidth}|}
  \hline
  Atom & Circuit & Min. delay in picoseconds \\
  \hline
  Write & \includegraphics[width=0.2\textwidth]{rw.pdf} & 176 \\
  \hline
  ReadAddWrite (RAW) & \includegraphics[width=0.2\textwidth]{raw.pdf} & 316\\
  \hline
  \pbox{0.1\textwidth}
  {Predicated\\
  ReadAddWrite (PRAW)} & \includegraphics[width=0.3\textwidth]{pred_raw.pdf}  & 393 \\
  \hline
  \end{tabular}
\end{scriptsize}
\caption{Minimum delay of an atom increases with circuit depth. MUX
stands for a multiplexer, RELOP stands for a relational operation between two
operands.}
\label{tab:circuits}
\end{table}
