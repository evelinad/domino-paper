\section{Evaluation}
\label{s:eval}

\begin{table*}[!t]
  \begin{scriptsize}
  \begin{tabular}{|p{0.15\textwidth}|p{0.8\textwidth}|}
  \hline
  Atom template & SKETCH shorthand\\
  \hline
  Write &
  {\begin{lstlisting}[style=customctable]
  x = mux2(pkt.f, ??);
  \end{lstlisting}} \\
  \hline
  Increment &
  {\begin{lstlisting}[style=customctable]
  x = mux3(x, pkt.f, ??) + mux2(1, 0);
  \end{lstlisting}} \\
  \hline
  ReadAddWrite &
  {\begin{lstlisting}[style=customctable]
  x = mux3(x, pkt.f, ??) + mux2(??, pkt.f);
  \end{lstlisting}} \\
  \hline
  \pbox{0.15\textwidth}
  {Predicated\\
  ReadAddWrite} &
  {\begin{lstlisting}[style=customctable]
  if(mux2(x, ??) rel_op mux3(pkt.f1, pkt.f2, ??)) {
    x = mux4(x, pkt.f1, pkt.f2, ??) + mux3(??, pkt.f1, pkt.f2);
  }
  \end{lstlisting}} \\
  \hline
  \pbox{0.15\textwidth}
  {If-Else\\
   ReadAddWrite} &
  {\begin{lstlisting}[style=customctable]
  if(mux2(x, ??) rel_op mux3(pkt.f1, pkt.f2, ??)) {
    x = mux4(x, pkt.f1, pkt.f2, ??) + mux3(??, pkt.f1, pkt.f2);
  } else {
    x = mux4(x, pkt.f1, pkt.f2, ??) + mux3(??, pkt.f1, pkt.f2)};
  }
  \end{lstlisting}} \\
  \hline
  Paired Updates &
  {\begin{lstlisting}[style=customctable]
  bit pred1 = mux3(x, y,  ??) rel_op mux3(pkt.f1, pkt.f2, ??);
  bit pred2 = mux3(x, y,  ??) rel_op mux3(pkt.f1, pkt.f2, ??);
  if (pred1) {
    x = mux4(x, pkt.f1, pkt.f2, ??) + mux3(??, pkt.f1, pkt.f2);
    y = mux4(y, pkt.f1, pkt.f2, ??) + mux3(??, pkt.f1, pkt.f2);
  } else if (pred2) {
    x = mux4(x, pkt.f1, pkt.f2, ??) + mux3(??, pkt.f1, pkt.f2);
    y = mux4(y, pkt.f1, pkt.f2, ??) + mux3(??, pkt.f1, pkt.f2);
  }
  \end{lstlisting}} \\
  \hline
  \end{tabular}
\end{scriptsize}
  \caption{Atom templates used in evaluation. rel\_op $\in \{<, >, != , ==\}$ stands for a relational operator. ?? refers to a SKETCH hole that can be filled in with an unsigned integer in the range $[0, 2^n]$.}
  \label{tab:templates}
\end{table*}

\begin{table*}[!t]
\begin{tabular}{|p{0.20\textwidth}|p{0.74\textwidth}|}
\hline
Algorithm & Stateful computation \\
\hline
Learning bloom filter & \pbox{0.74\textwidth}{Set membership bit on every packet.
                                              We ``learn'' a new packet by adding it to the set.}\\
\hline
%TODO: Ask Lavanya exactly how heavy hitters works.
Heavy Hitters~\cite{opensketch} & Increment Count-Min Sketch~\cite{cormode} on every packet \\
\hline
Flowlet switching~\cite{flowlets} & Update saved next hop if flowlet threshold is exceeded \\
\hline
RCP~\cite{rcp} & Accumulate RTT sum if RTT is under maximum allowable RTT \\
\hline
Periodic sampling & \pbox{0.74\textwidth}{Sample/Mark a packet if packet count reaches N; reset count at N.} \\
\hline
CONGA~\cite{conga} & \pbox{0.74\textwidth}{Update best path's utilization/id if we see a better path.\\
                                           Update best path utilization alone if it changes.} \\
\hline
\end{tabular}
\caption{Data-plane algorithms}
\label{tab:algos}
\end{table*}

\begin{table*}[!t]
  \begin{tabular}{|p{0.20\textwidth}|p{0.04\textwidth}|p{0.09\textwidth}|p{0.14\textwidth}|p{0.14\textwidth}|p{0.14\textwidth}|p{0.05\textwidth}|}
  \hline
    & Write & Increment & ReadAddWrite & Predicated ReadAddWrite & IfElse ReadAddWrite & Paired Updates \\
  \hline
  Learning bloom filter & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark \\
  \hline
  Heavy hitters          & \xmark & \cmark & \cmark & \cmark & \cmark & \cmark \\
  \hline
  Flowlet switching      & \xmark & \xmark & \xmark & \cmark & \cmark & \cmark \\
  \hline
  RCP                    & \xmark & \xmark & \xmark & \cmark & \cmark & \cmark \\
  \hline
  Periodic sampling & \xmark & \xmark & \xmark & \xmark & \cmark & \cmark \\
  \hline
  CONGA                  & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark \\
  \hline
  \end{tabular}
\caption{Data-plane algorithm implementability on different \absmachine instances}
\label{table:eval}
\end{table*}

%10. Alvin's feedback: Write about our experience writing these programs. Similar to Steven Chong's PLDI paper.
To evaluate \pktlanguage, we express several well-known data-plane algorithms
(Table~\ref{tab:algos}) using \pktlanguage and determine if they are
implementable on different \absmachine instances that provide different
stateful atoms (Table~\ref{tab:templates}).

\subsection{Experimental procedure}
As mentioned earlier, we consider only stateful atoms because we assume
stateless codelets map one-to-one to stateless atoms for all
\absmachine instances. For simplicity, the stateful atoms we consider only
permit updates to state variables and forbid packet field updates that might be
result from these state updates. Assuming the \absmachine instance provides an atom
to read a state variable\footnote{We think this is reasonable because the
inability to read a state variable renders them meaningless!}, such packet
updates can be treated as stateless operations in subsequent pipeline stages.

We represent atoms using their atom templates in Table~\ref{tab:templates},
employing a shorthand notation for SKETCH. We use ``x'' and ``y'' for state
variables, and muxN(a1, a2, ..., aN) to represent a configurable choice between
N operands such as the choice made by the 2-to-1 multiplexer in
Figure~\ref{fig:sketch}a.

%Anirudh->Alvin: Is it clear now that each instance provides exactly one atom.
We also assume every \absmachine instance provides exactly one
stateful atom.  Table~\ref{tab:templates} gradually increases the capability of
this single atom provided by a \absmachine instance.  The atoms in
Table~\ref{tab:templates} form a containment hierarchy: going from top to
bottom, each atom is strictly more expressive than its predecessor to the top
and hence can express all data-plane algorithms that its predecessor can.

We now consider every atom/\absmachine instance from Table~\ref{tab:templates},
and every data-plane algorithm from Table~\ref{tab:algos} to determine if each
algorithm is \textit{implementable} on a particular \absmachine instance. We
say an algorithm is implementable on a \absmachine instance, if every stateful
codelet within the data-plane algorithm can be mapped (\S\ref{ss:code_gen}) to
the single stateful atom provided by the \absmachine instance.

\subsection{Interpreting these results}
Table~\ref{table:eval} presents our results. There are two ways to interpret
them. For a network programmer, the matrix in Table~\ref{table:eval} tells her
if a particular data-plane algorithm can be implemented at line rate, assuming
the \absmachine instance provides a particular stateful atom.

For an ASIC engineer designing programmable switching chips, the same table
describes the algorithms that are implementable with a particular atom. For
instance, the paired updates atom can implement all six algorithms shown in
Table~\ref{table:eval}, while a simpler increment atom can implement only
two.

These results will change as programmable switches evolve and network
programmers continuously push chip boundaries with new algorithms.  The larger
takeaway from this evaluation is that programming in \pktlanguage allows us to
rigorously determine if a particular high-level algorithm is implementable at
line rate on a particular \absmachine instance and conversely, if a particular
atom suffices to implement a large number of algorithms.
