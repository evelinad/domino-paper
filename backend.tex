\section{The \pktlanguage compiler backend}

\subsection{Expression flattening to the three-address format}
As a first step, we convert code into the three-address format. In the
three-address format, all instructions are either reads / writes into stateful
variables or carry out packet manipulations of of the form: \texttt{pkt.f1 =
pkt.f2 op pkt.f3;} where \texttt{op} includes all arithmetic, logical, and
relational operators. We also allow either pkt.f2 or pkt.f3 to be an opaque
function call of multiple packet fields, because \pktlanguage assumes opaque
functions are supported in hardware. The three-address format is similar to
P4's action primitives today~\cite{p4spec}.

Generating code for the three-address format is straightforward: we flatten
expressions that are not already in three-address format, by introducing enough
temporaries. For instance, \texttt{pkt.f = pkt.f1 + pkt.f2 - pkt.f3;} would be
flattened to \texttt{pkt.tmp = pkt.f2 - pkt.f3;} followed by \texttt{pkt.f =
pkt.f1 + pkt.tmp;}

\subsection{Code partitioning}
At this point, the code is still in sequential form. Code partitioning is the
turns sequential code into an atom grid that can be run by \absmachine , which
exploits parallelism within and across pipeline stages.

To partition code, we carry out the following steps:
\begin{enumerate}
  \item Create a node for each statement in the packet transaction after expression flattening. % TODO: Figure.
  \item Create a bidrectional edge between N1 and N2 where N1 is a read from a state scalar / state array and N2 is a write into a state scalar / state array.
  \item Create an edge (N1, N2) for every pair of nodes N1, N2 where N2 reads something written by N1.
  \item Generate strongly connected components of the resulting graph $G$.
  \item Condense strongly connected components into larger nodes to create an induced DAG from (a possibly) cyclic $G$.
  \item Schedule the resulting DAG using critical path scheduling~\cite{crit_path_sched}.
%TODO: Throw in a whole bunch of figures.
\end{enumerate}


%%The compiler backend needs to understand the
%%characteristics of the abstract machine when generating code. Concretely,
%%we need an execution model that limits the computations possible within each
%%atom in \absmachine. We assume distinct models for atoms that are completely
%%stateless (only manipulate packet fields) vs. atoms that manipulate state.

%TODO: How do we structure this section?
% --> Partitioning first followed by instruction selection?
% We currently do it somewhat differently in domino, where we do
% expression flattening (instruction selection for stateless atoms)
% then partitioning,
% then instruction selection for stateful atoms.
% It's conceivable we could flip this around, but I am not sure how easy it is.

\subsection{Stateful atoms}
% Backend: expr_flattener, instuction_selection, backend synthesis.
%%

